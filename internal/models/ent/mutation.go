// Code generated by ent, DO NOT EDIT.

package openuem_ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/doncicuto/openuem_ent/agent"
	"github.com/doncicuto/openuem_ent/antivirus"
	"github.com/doncicuto/openuem_ent/app"
	"github.com/doncicuto/openuem_ent/certificate"
	"github.com/doncicuto/openuem_ent/component"
	"github.com/doncicuto/openuem_ent/computer"
	"github.com/doncicuto/openuem_ent/deployment"
	"github.com/doncicuto/openuem_ent/logicaldisk"
	"github.com/doncicuto/openuem_ent/metadata"
	"github.com/doncicuto/openuem_ent/monitor"
	"github.com/doncicuto/openuem_ent/networkadapter"
	"github.com/doncicuto/openuem_ent/operatingsystem"
	"github.com/doncicuto/openuem_ent/orgmetadata"
	"github.com/doncicuto/openuem_ent/predicate"
	"github.com/doncicuto/openuem_ent/printer"
	"github.com/doncicuto/openuem_ent/release"
	"github.com/doncicuto/openuem_ent/revocation"
	"github.com/doncicuto/openuem_ent/sessions"
	"github.com/doncicuto/openuem_ent/settings"
	"github.com/doncicuto/openuem_ent/share"
	"github.com/doncicuto/openuem_ent/systemupdate"
	"github.com/doncicuto/openuem_ent/tag"
	"github.com/doncicuto/openuem_ent/update"
	"github.com/doncicuto/openuem_ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgent           = "Agent"
	TypeAntivirus       = "Antivirus"
	TypeApp             = "App"
	TypeCertificate     = "Certificate"
	TypeComponent       = "Component"
	TypeComputer        = "Computer"
	TypeDeployment      = "Deployment"
	TypeLogicalDisk     = "LogicalDisk"
	TypeMetadata        = "Metadata"
	TypeMonitor         = "Monitor"
	TypeNetworkAdapter  = "NetworkAdapter"
	TypeOperatingSystem = "OperatingSystem"
	TypeOrgMetadata     = "OrgMetadata"
	TypePrinter         = "Printer"
	TypeRelease         = "Release"
	TypeRevocation      = "Revocation"
	TypeSessions        = "Sessions"
	TypeSettings        = "Settings"
	TypeShare           = "Share"
	TypeSystemUpdate    = "SystemUpdate"
	TypeTag             = "Tag"
	TypeUpdate          = "Update"
	TypeUser            = "User"
)

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	os                      *string
	hostname                *string
	ip                      *string
	mac                     *string
	first_contact           *time.Time
	last_contact            *time.Time
	vnc                     *string
	notes                   *string
	update_task_status      *string
	update_task_description *string
	update_task_result      *string
	update_task_execution   *time.Time
	update_task_version     *string
	vnc_proxy_port          *string
	sftp_port               *string
	status                  *agent.Status
	certificate_ready       *bool
	restart_required        *bool
	clearedFields           map[string]struct{}
	computer                *int
	clearedcomputer         bool
	operatingsystem         *int
	clearedoperatingsystem  bool
	systemupdate            *int
	clearedsystemupdate     bool
	antivirus               *int
	clearedantivirus        bool
	logicaldisks            map[int]struct{}
	removedlogicaldisks     map[int]struct{}
	clearedlogicaldisks     bool
	apps                    map[int]struct{}
	removedapps             map[int]struct{}
	clearedapps             bool
	monitors                map[int]struct{}
	removedmonitors         map[int]struct{}
	clearedmonitors         bool
	shares                  map[int]struct{}
	removedshares           map[int]struct{}
	clearedshares           bool
	printers                map[int]struct{}
	removedprinters         map[int]struct{}
	clearedprinters         bool
	networkadapters         map[int]struct{}
	removednetworkadapters  map[int]struct{}
	clearednetworkadapters  bool
	deployments             map[int]struct{}
	removeddeployments      map[int]struct{}
	cleareddeployments      bool
	updates                 map[int]struct{}
	removedupdates          map[int]struct{}
	clearedupdates          bool
	tags                    map[int]struct{}
	removedtags             map[int]struct{}
	clearedtags             bool
	metadata                map[int]struct{}
	removedmetadata         map[int]struct{}
	clearedmetadata         bool
	release                 *int
	clearedrelease          bool
	done                    bool
	oldValue                func(context.Context) (*Agent, error)
	predicates              []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id string) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agent entities.
func (m *AgentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOs sets the "os" field.
func (m *AgentMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *AgentMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *AgentMutation) ResetOs() {
	m.os = nil
}

// SetHostname sets the "hostname" field.
func (m *AgentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *AgentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *AgentMutation) ResetHostname() {
	m.hostname = nil
}

// SetIP sets the "ip" field.
func (m *AgentMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AgentMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AgentMutation) ResetIP() {
	m.ip = nil
}

// SetMAC sets the "mac" field.
func (m *AgentMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *AgentMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *AgentMutation) ResetMAC() {
	m.mac = nil
}

// SetFirstContact sets the "first_contact" field.
func (m *AgentMutation) SetFirstContact(t time.Time) {
	m.first_contact = &t
}

// FirstContact returns the value of the "first_contact" field in the mutation.
func (m *AgentMutation) FirstContact() (r time.Time, exists bool) {
	v := m.first_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstContact returns the old "first_contact" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldFirstContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstContact: %w", err)
	}
	return oldValue.FirstContact, nil
}

// ClearFirstContact clears the value of the "first_contact" field.
func (m *AgentMutation) ClearFirstContact() {
	m.first_contact = nil
	m.clearedFields[agent.FieldFirstContact] = struct{}{}
}

// FirstContactCleared returns if the "first_contact" field was cleared in this mutation.
func (m *AgentMutation) FirstContactCleared() bool {
	_, ok := m.clearedFields[agent.FieldFirstContact]
	return ok
}

// ResetFirstContact resets all changes to the "first_contact" field.
func (m *AgentMutation) ResetFirstContact() {
	m.first_contact = nil
	delete(m.clearedFields, agent.FieldFirstContact)
}

// SetLastContact sets the "last_contact" field.
func (m *AgentMutation) SetLastContact(t time.Time) {
	m.last_contact = &t
}

// LastContact returns the value of the "last_contact" field in the mutation.
func (m *AgentMutation) LastContact() (r time.Time, exists bool) {
	v := m.last_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldLastContact returns the old "last_contact" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastContact(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastContact: %w", err)
	}
	return oldValue.LastContact, nil
}

// ClearLastContact clears the value of the "last_contact" field.
func (m *AgentMutation) ClearLastContact() {
	m.last_contact = nil
	m.clearedFields[agent.FieldLastContact] = struct{}{}
}

// LastContactCleared returns if the "last_contact" field was cleared in this mutation.
func (m *AgentMutation) LastContactCleared() bool {
	_, ok := m.clearedFields[agent.FieldLastContact]
	return ok
}

// ResetLastContact resets all changes to the "last_contact" field.
func (m *AgentMutation) ResetLastContact() {
	m.last_contact = nil
	delete(m.clearedFields, agent.FieldLastContact)
}

// SetVnc sets the "vnc" field.
func (m *AgentMutation) SetVnc(s string) {
	m.vnc = &s
}

// Vnc returns the value of the "vnc" field in the mutation.
func (m *AgentMutation) Vnc() (r string, exists bool) {
	v := m.vnc
	if v == nil {
		return
	}
	return *v, true
}

// OldVnc returns the old "vnc" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVnc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVnc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVnc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVnc: %w", err)
	}
	return oldValue.Vnc, nil
}

// ClearVnc clears the value of the "vnc" field.
func (m *AgentMutation) ClearVnc() {
	m.vnc = nil
	m.clearedFields[agent.FieldVnc] = struct{}{}
}

// VncCleared returns if the "vnc" field was cleared in this mutation.
func (m *AgentMutation) VncCleared() bool {
	_, ok := m.clearedFields[agent.FieldVnc]
	return ok
}

// ResetVnc resets all changes to the "vnc" field.
func (m *AgentMutation) ResetVnc() {
	m.vnc = nil
	delete(m.clearedFields, agent.FieldVnc)
}

// SetNotes sets the "notes" field.
func (m *AgentMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AgentMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AgentMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[agent.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AgentMutation) NotesCleared() bool {
	_, ok := m.clearedFields[agent.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AgentMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, agent.FieldNotes)
}

// SetUpdateTaskStatus sets the "update_task_status" field.
func (m *AgentMutation) SetUpdateTaskStatus(s string) {
	m.update_task_status = &s
}

// UpdateTaskStatus returns the value of the "update_task_status" field in the mutation.
func (m *AgentMutation) UpdateTaskStatus() (r string, exists bool) {
	v := m.update_task_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskStatus returns the old "update_task_status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskStatus: %w", err)
	}
	return oldValue.UpdateTaskStatus, nil
}

// ClearUpdateTaskStatus clears the value of the "update_task_status" field.
func (m *AgentMutation) ClearUpdateTaskStatus() {
	m.update_task_status = nil
	m.clearedFields[agent.FieldUpdateTaskStatus] = struct{}{}
}

// UpdateTaskStatusCleared returns if the "update_task_status" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskStatusCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskStatus]
	return ok
}

// ResetUpdateTaskStatus resets all changes to the "update_task_status" field.
func (m *AgentMutation) ResetUpdateTaskStatus() {
	m.update_task_status = nil
	delete(m.clearedFields, agent.FieldUpdateTaskStatus)
}

// SetUpdateTaskDescription sets the "update_task_description" field.
func (m *AgentMutation) SetUpdateTaskDescription(s string) {
	m.update_task_description = &s
}

// UpdateTaskDescription returns the value of the "update_task_description" field in the mutation.
func (m *AgentMutation) UpdateTaskDescription() (r string, exists bool) {
	v := m.update_task_description
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskDescription returns the old "update_task_description" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskDescription: %w", err)
	}
	return oldValue.UpdateTaskDescription, nil
}

// ClearUpdateTaskDescription clears the value of the "update_task_description" field.
func (m *AgentMutation) ClearUpdateTaskDescription() {
	m.update_task_description = nil
	m.clearedFields[agent.FieldUpdateTaskDescription] = struct{}{}
}

// UpdateTaskDescriptionCleared returns if the "update_task_description" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskDescriptionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskDescription]
	return ok
}

// ResetUpdateTaskDescription resets all changes to the "update_task_description" field.
func (m *AgentMutation) ResetUpdateTaskDescription() {
	m.update_task_description = nil
	delete(m.clearedFields, agent.FieldUpdateTaskDescription)
}

// SetUpdateTaskResult sets the "update_task_result" field.
func (m *AgentMutation) SetUpdateTaskResult(s string) {
	m.update_task_result = &s
}

// UpdateTaskResult returns the value of the "update_task_result" field in the mutation.
func (m *AgentMutation) UpdateTaskResult() (r string, exists bool) {
	v := m.update_task_result
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskResult returns the old "update_task_result" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskResult: %w", err)
	}
	return oldValue.UpdateTaskResult, nil
}

// ClearUpdateTaskResult clears the value of the "update_task_result" field.
func (m *AgentMutation) ClearUpdateTaskResult() {
	m.update_task_result = nil
	m.clearedFields[agent.FieldUpdateTaskResult] = struct{}{}
}

// UpdateTaskResultCleared returns if the "update_task_result" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskResultCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskResult]
	return ok
}

// ResetUpdateTaskResult resets all changes to the "update_task_result" field.
func (m *AgentMutation) ResetUpdateTaskResult() {
	m.update_task_result = nil
	delete(m.clearedFields, agent.FieldUpdateTaskResult)
}

// SetUpdateTaskExecution sets the "update_task_execution" field.
func (m *AgentMutation) SetUpdateTaskExecution(t time.Time) {
	m.update_task_execution = &t
}

// UpdateTaskExecution returns the value of the "update_task_execution" field in the mutation.
func (m *AgentMutation) UpdateTaskExecution() (r time.Time, exists bool) {
	v := m.update_task_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskExecution returns the old "update_task_execution" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskExecution(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskExecution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskExecution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskExecution: %w", err)
	}
	return oldValue.UpdateTaskExecution, nil
}

// ClearUpdateTaskExecution clears the value of the "update_task_execution" field.
func (m *AgentMutation) ClearUpdateTaskExecution() {
	m.update_task_execution = nil
	m.clearedFields[agent.FieldUpdateTaskExecution] = struct{}{}
}

// UpdateTaskExecutionCleared returns if the "update_task_execution" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskExecutionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskExecution]
	return ok
}

// ResetUpdateTaskExecution resets all changes to the "update_task_execution" field.
func (m *AgentMutation) ResetUpdateTaskExecution() {
	m.update_task_execution = nil
	delete(m.clearedFields, agent.FieldUpdateTaskExecution)
}

// SetUpdateTaskVersion sets the "update_task_version" field.
func (m *AgentMutation) SetUpdateTaskVersion(s string) {
	m.update_task_version = &s
}

// UpdateTaskVersion returns the value of the "update_task_version" field in the mutation.
func (m *AgentMutation) UpdateTaskVersion() (r string, exists bool) {
	v := m.update_task_version
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTaskVersion returns the old "update_task_version" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdateTaskVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTaskVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTaskVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTaskVersion: %w", err)
	}
	return oldValue.UpdateTaskVersion, nil
}

// ClearUpdateTaskVersion clears the value of the "update_task_version" field.
func (m *AgentMutation) ClearUpdateTaskVersion() {
	m.update_task_version = nil
	m.clearedFields[agent.FieldUpdateTaskVersion] = struct{}{}
}

// UpdateTaskVersionCleared returns if the "update_task_version" field was cleared in this mutation.
func (m *AgentMutation) UpdateTaskVersionCleared() bool {
	_, ok := m.clearedFields[agent.FieldUpdateTaskVersion]
	return ok
}

// ResetUpdateTaskVersion resets all changes to the "update_task_version" field.
func (m *AgentMutation) ResetUpdateTaskVersion() {
	m.update_task_version = nil
	delete(m.clearedFields, agent.FieldUpdateTaskVersion)
}

// SetVncProxyPort sets the "vnc_proxy_port" field.
func (m *AgentMutation) SetVncProxyPort(s string) {
	m.vnc_proxy_port = &s
}

// VncProxyPort returns the value of the "vnc_proxy_port" field in the mutation.
func (m *AgentMutation) VncProxyPort() (r string, exists bool) {
	v := m.vnc_proxy_port
	if v == nil {
		return
	}
	return *v, true
}

// OldVncProxyPort returns the old "vnc_proxy_port" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVncProxyPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVncProxyPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVncProxyPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVncProxyPort: %w", err)
	}
	return oldValue.VncProxyPort, nil
}

// ClearVncProxyPort clears the value of the "vnc_proxy_port" field.
func (m *AgentMutation) ClearVncProxyPort() {
	m.vnc_proxy_port = nil
	m.clearedFields[agent.FieldVncProxyPort] = struct{}{}
}

// VncProxyPortCleared returns if the "vnc_proxy_port" field was cleared in this mutation.
func (m *AgentMutation) VncProxyPortCleared() bool {
	_, ok := m.clearedFields[agent.FieldVncProxyPort]
	return ok
}

// ResetVncProxyPort resets all changes to the "vnc_proxy_port" field.
func (m *AgentMutation) ResetVncProxyPort() {
	m.vnc_proxy_port = nil
	delete(m.clearedFields, agent.FieldVncProxyPort)
}

// SetSftpPort sets the "sftp_port" field.
func (m *AgentMutation) SetSftpPort(s string) {
	m.sftp_port = &s
}

// SftpPort returns the value of the "sftp_port" field in the mutation.
func (m *AgentMutation) SftpPort() (r string, exists bool) {
	v := m.sftp_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSftpPort returns the old "sftp_port" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSftpPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSftpPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSftpPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSftpPort: %w", err)
	}
	return oldValue.SftpPort, nil
}

// ClearSftpPort clears the value of the "sftp_port" field.
func (m *AgentMutation) ClearSftpPort() {
	m.sftp_port = nil
	m.clearedFields[agent.FieldSftpPort] = struct{}{}
}

// SftpPortCleared returns if the "sftp_port" field was cleared in this mutation.
func (m *AgentMutation) SftpPortCleared() bool {
	_, ok := m.clearedFields[agent.FieldSftpPort]
	return ok
}

// ResetSftpPort resets all changes to the "sftp_port" field.
func (m *AgentMutation) ResetSftpPort() {
	m.sftp_port = nil
	delete(m.clearedFields, agent.FieldSftpPort)
}

// SetStatus sets the "status" field.
func (m *AgentMutation) SetStatus(a agent.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentMutation) Status() (r agent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldStatus(ctx context.Context) (v agent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AgentMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[agent.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AgentMutation) StatusCleared() bool {
	_, ok := m.clearedFields[agent.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, agent.FieldStatus)
}

// SetCertificateReady sets the "certificate_ready" field.
func (m *AgentMutation) SetCertificateReady(b bool) {
	m.certificate_ready = &b
}

// CertificateReady returns the value of the "certificate_ready" field in the mutation.
func (m *AgentMutation) CertificateReady() (r bool, exists bool) {
	v := m.certificate_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateReady returns the old "certificate_ready" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCertificateReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateReady: %w", err)
	}
	return oldValue.CertificateReady, nil
}

// ClearCertificateReady clears the value of the "certificate_ready" field.
func (m *AgentMutation) ClearCertificateReady() {
	m.certificate_ready = nil
	m.clearedFields[agent.FieldCertificateReady] = struct{}{}
}

// CertificateReadyCleared returns if the "certificate_ready" field was cleared in this mutation.
func (m *AgentMutation) CertificateReadyCleared() bool {
	_, ok := m.clearedFields[agent.FieldCertificateReady]
	return ok
}

// ResetCertificateReady resets all changes to the "certificate_ready" field.
func (m *AgentMutation) ResetCertificateReady() {
	m.certificate_ready = nil
	delete(m.clearedFields, agent.FieldCertificateReady)
}

// SetRestartRequired sets the "restart_required" field.
func (m *AgentMutation) SetRestartRequired(b bool) {
	m.restart_required = &b
}

// RestartRequired returns the value of the "restart_required" field in the mutation.
func (m *AgentMutation) RestartRequired() (r bool, exists bool) {
	v := m.restart_required
	if v == nil {
		return
	}
	return *v, true
}

// OldRestartRequired returns the old "restart_required" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRestartRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestartRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestartRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestartRequired: %w", err)
	}
	return oldValue.RestartRequired, nil
}

// ClearRestartRequired clears the value of the "restart_required" field.
func (m *AgentMutation) ClearRestartRequired() {
	m.restart_required = nil
	m.clearedFields[agent.FieldRestartRequired] = struct{}{}
}

// RestartRequiredCleared returns if the "restart_required" field was cleared in this mutation.
func (m *AgentMutation) RestartRequiredCleared() bool {
	_, ok := m.clearedFields[agent.FieldRestartRequired]
	return ok
}

// ResetRestartRequired resets all changes to the "restart_required" field.
func (m *AgentMutation) ResetRestartRequired() {
	m.restart_required = nil
	delete(m.clearedFields, agent.FieldRestartRequired)
}

// SetComputerID sets the "computer" edge to the Computer entity by id.
func (m *AgentMutation) SetComputerID(id int) {
	m.computer = &id
}

// ClearComputer clears the "computer" edge to the Computer entity.
func (m *AgentMutation) ClearComputer() {
	m.clearedcomputer = true
}

// ComputerCleared reports if the "computer" edge to the Computer entity was cleared.
func (m *AgentMutation) ComputerCleared() bool {
	return m.clearedcomputer
}

// ComputerID returns the "computer" edge ID in the mutation.
func (m *AgentMutation) ComputerID() (id int, exists bool) {
	if m.computer != nil {
		return *m.computer, true
	}
	return
}

// ComputerIDs returns the "computer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComputerID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) ComputerIDs() (ids []int) {
	if id := m.computer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComputer resets all changes to the "computer" edge.
func (m *AgentMutation) ResetComputer() {
	m.computer = nil
	m.clearedcomputer = false
}

// SetOperatingsystemID sets the "operatingsystem" edge to the OperatingSystem entity by id.
func (m *AgentMutation) SetOperatingsystemID(id int) {
	m.operatingsystem = &id
}

// ClearOperatingsystem clears the "operatingsystem" edge to the OperatingSystem entity.
func (m *AgentMutation) ClearOperatingsystem() {
	m.clearedoperatingsystem = true
}

// OperatingsystemCleared reports if the "operatingsystem" edge to the OperatingSystem entity was cleared.
func (m *AgentMutation) OperatingsystemCleared() bool {
	return m.clearedoperatingsystem
}

// OperatingsystemID returns the "operatingsystem" edge ID in the mutation.
func (m *AgentMutation) OperatingsystemID() (id int, exists bool) {
	if m.operatingsystem != nil {
		return *m.operatingsystem, true
	}
	return
}

// OperatingsystemIDs returns the "operatingsystem" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OperatingsystemID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) OperatingsystemIDs() (ids []int) {
	if id := m.operatingsystem; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperatingsystem resets all changes to the "operatingsystem" edge.
func (m *AgentMutation) ResetOperatingsystem() {
	m.operatingsystem = nil
	m.clearedoperatingsystem = false
}

// SetSystemupdateID sets the "systemupdate" edge to the SystemUpdate entity by id.
func (m *AgentMutation) SetSystemupdateID(id int) {
	m.systemupdate = &id
}

// ClearSystemupdate clears the "systemupdate" edge to the SystemUpdate entity.
func (m *AgentMutation) ClearSystemupdate() {
	m.clearedsystemupdate = true
}

// SystemupdateCleared reports if the "systemupdate" edge to the SystemUpdate entity was cleared.
func (m *AgentMutation) SystemupdateCleared() bool {
	return m.clearedsystemupdate
}

// SystemupdateID returns the "systemupdate" edge ID in the mutation.
func (m *AgentMutation) SystemupdateID() (id int, exists bool) {
	if m.systemupdate != nil {
		return *m.systemupdate, true
	}
	return
}

// SystemupdateIDs returns the "systemupdate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SystemupdateID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) SystemupdateIDs() (ids []int) {
	if id := m.systemupdate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSystemupdate resets all changes to the "systemupdate" edge.
func (m *AgentMutation) ResetSystemupdate() {
	m.systemupdate = nil
	m.clearedsystemupdate = false
}

// SetAntivirusID sets the "antivirus" edge to the Antivirus entity by id.
func (m *AgentMutation) SetAntivirusID(id int) {
	m.antivirus = &id
}

// ClearAntivirus clears the "antivirus" edge to the Antivirus entity.
func (m *AgentMutation) ClearAntivirus() {
	m.clearedantivirus = true
}

// AntivirusCleared reports if the "antivirus" edge to the Antivirus entity was cleared.
func (m *AgentMutation) AntivirusCleared() bool {
	return m.clearedantivirus
}

// AntivirusID returns the "antivirus" edge ID in the mutation.
func (m *AgentMutation) AntivirusID() (id int, exists bool) {
	if m.antivirus != nil {
		return *m.antivirus, true
	}
	return
}

// AntivirusIDs returns the "antivirus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AntivirusID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) AntivirusIDs() (ids []int) {
	if id := m.antivirus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAntivirus resets all changes to the "antivirus" edge.
func (m *AgentMutation) ResetAntivirus() {
	m.antivirus = nil
	m.clearedantivirus = false
}

// AddLogicaldiskIDs adds the "logicaldisks" edge to the LogicalDisk entity by ids.
func (m *AgentMutation) AddLogicaldiskIDs(ids ...int) {
	if m.logicaldisks == nil {
		m.logicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		m.logicaldisks[ids[i]] = struct{}{}
	}
}

// ClearLogicaldisks clears the "logicaldisks" edge to the LogicalDisk entity.
func (m *AgentMutation) ClearLogicaldisks() {
	m.clearedlogicaldisks = true
}

// LogicaldisksCleared reports if the "logicaldisks" edge to the LogicalDisk entity was cleared.
func (m *AgentMutation) LogicaldisksCleared() bool {
	return m.clearedlogicaldisks
}

// RemoveLogicaldiskIDs removes the "logicaldisks" edge to the LogicalDisk entity by IDs.
func (m *AgentMutation) RemoveLogicaldiskIDs(ids ...int) {
	if m.removedlogicaldisks == nil {
		m.removedlogicaldisks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.logicaldisks, ids[i])
		m.removedlogicaldisks[ids[i]] = struct{}{}
	}
}

// RemovedLogicaldisks returns the removed IDs of the "logicaldisks" edge to the LogicalDisk entity.
func (m *AgentMutation) RemovedLogicaldisksIDs() (ids []int) {
	for id := range m.removedlogicaldisks {
		ids = append(ids, id)
	}
	return
}

// LogicaldisksIDs returns the "logicaldisks" edge IDs in the mutation.
func (m *AgentMutation) LogicaldisksIDs() (ids []int) {
	for id := range m.logicaldisks {
		ids = append(ids, id)
	}
	return
}

// ResetLogicaldisks resets all changes to the "logicaldisks" edge.
func (m *AgentMutation) ResetLogicaldisks() {
	m.logicaldisks = nil
	m.clearedlogicaldisks = false
	m.removedlogicaldisks = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *AgentMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *AgentMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *AgentMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *AgentMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *AgentMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *AgentMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *AgentMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddMonitorIDs adds the "monitors" edge to the Monitor entity by ids.
func (m *AgentMutation) AddMonitorIDs(ids ...int) {
	if m.monitors == nil {
		m.monitors = make(map[int]struct{})
	}
	for i := range ids {
		m.monitors[ids[i]] = struct{}{}
	}
}

// ClearMonitors clears the "monitors" edge to the Monitor entity.
func (m *AgentMutation) ClearMonitors() {
	m.clearedmonitors = true
}

// MonitorsCleared reports if the "monitors" edge to the Monitor entity was cleared.
func (m *AgentMutation) MonitorsCleared() bool {
	return m.clearedmonitors
}

// RemoveMonitorIDs removes the "monitors" edge to the Monitor entity by IDs.
func (m *AgentMutation) RemoveMonitorIDs(ids ...int) {
	if m.removedmonitors == nil {
		m.removedmonitors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.monitors, ids[i])
		m.removedmonitors[ids[i]] = struct{}{}
	}
}

// RemovedMonitors returns the removed IDs of the "monitors" edge to the Monitor entity.
func (m *AgentMutation) RemovedMonitorsIDs() (ids []int) {
	for id := range m.removedmonitors {
		ids = append(ids, id)
	}
	return
}

// MonitorsIDs returns the "monitors" edge IDs in the mutation.
func (m *AgentMutation) MonitorsIDs() (ids []int) {
	for id := range m.monitors {
		ids = append(ids, id)
	}
	return
}

// ResetMonitors resets all changes to the "monitors" edge.
func (m *AgentMutation) ResetMonitors() {
	m.monitors = nil
	m.clearedmonitors = false
	m.removedmonitors = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *AgentMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *AgentMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *AgentMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *AgentMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *AgentMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *AgentMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *AgentMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// AddPrinterIDs adds the "printers" edge to the Printer entity by ids.
func (m *AgentMutation) AddPrinterIDs(ids ...int) {
	if m.printers == nil {
		m.printers = make(map[int]struct{})
	}
	for i := range ids {
		m.printers[ids[i]] = struct{}{}
	}
}

// ClearPrinters clears the "printers" edge to the Printer entity.
func (m *AgentMutation) ClearPrinters() {
	m.clearedprinters = true
}

// PrintersCleared reports if the "printers" edge to the Printer entity was cleared.
func (m *AgentMutation) PrintersCleared() bool {
	return m.clearedprinters
}

// RemovePrinterIDs removes the "printers" edge to the Printer entity by IDs.
func (m *AgentMutation) RemovePrinterIDs(ids ...int) {
	if m.removedprinters == nil {
		m.removedprinters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.printers, ids[i])
		m.removedprinters[ids[i]] = struct{}{}
	}
}

// RemovedPrinters returns the removed IDs of the "printers" edge to the Printer entity.
func (m *AgentMutation) RemovedPrintersIDs() (ids []int) {
	for id := range m.removedprinters {
		ids = append(ids, id)
	}
	return
}

// PrintersIDs returns the "printers" edge IDs in the mutation.
func (m *AgentMutation) PrintersIDs() (ids []int) {
	for id := range m.printers {
		ids = append(ids, id)
	}
	return
}

// ResetPrinters resets all changes to the "printers" edge.
func (m *AgentMutation) ResetPrinters() {
	m.printers = nil
	m.clearedprinters = false
	m.removedprinters = nil
}

// AddNetworkadapterIDs adds the "networkadapters" edge to the NetworkAdapter entity by ids.
func (m *AgentMutation) AddNetworkadapterIDs(ids ...int) {
	if m.networkadapters == nil {
		m.networkadapters = make(map[int]struct{})
	}
	for i := range ids {
		m.networkadapters[ids[i]] = struct{}{}
	}
}

// ClearNetworkadapters clears the "networkadapters" edge to the NetworkAdapter entity.
func (m *AgentMutation) ClearNetworkadapters() {
	m.clearednetworkadapters = true
}

// NetworkadaptersCleared reports if the "networkadapters" edge to the NetworkAdapter entity was cleared.
func (m *AgentMutation) NetworkadaptersCleared() bool {
	return m.clearednetworkadapters
}

// RemoveNetworkadapterIDs removes the "networkadapters" edge to the NetworkAdapter entity by IDs.
func (m *AgentMutation) RemoveNetworkadapterIDs(ids ...int) {
	if m.removednetworkadapters == nil {
		m.removednetworkadapters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.networkadapters, ids[i])
		m.removednetworkadapters[ids[i]] = struct{}{}
	}
}

// RemovedNetworkadapters returns the removed IDs of the "networkadapters" edge to the NetworkAdapter entity.
func (m *AgentMutation) RemovedNetworkadaptersIDs() (ids []int) {
	for id := range m.removednetworkadapters {
		ids = append(ids, id)
	}
	return
}

// NetworkadaptersIDs returns the "networkadapters" edge IDs in the mutation.
func (m *AgentMutation) NetworkadaptersIDs() (ids []int) {
	for id := range m.networkadapters {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkadapters resets all changes to the "networkadapters" edge.
func (m *AgentMutation) ResetNetworkadapters() {
	m.networkadapters = nil
	m.clearednetworkadapters = false
	m.removednetworkadapters = nil
}

// AddDeploymentIDs adds the "deployments" edge to the Deployment entity by ids.
func (m *AgentMutation) AddDeploymentIDs(ids ...int) {
	if m.deployments == nil {
		m.deployments = make(map[int]struct{})
	}
	for i := range ids {
		m.deployments[ids[i]] = struct{}{}
	}
}

// ClearDeployments clears the "deployments" edge to the Deployment entity.
func (m *AgentMutation) ClearDeployments() {
	m.cleareddeployments = true
}

// DeploymentsCleared reports if the "deployments" edge to the Deployment entity was cleared.
func (m *AgentMutation) DeploymentsCleared() bool {
	return m.cleareddeployments
}

// RemoveDeploymentIDs removes the "deployments" edge to the Deployment entity by IDs.
func (m *AgentMutation) RemoveDeploymentIDs(ids ...int) {
	if m.removeddeployments == nil {
		m.removeddeployments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.deployments, ids[i])
		m.removeddeployments[ids[i]] = struct{}{}
	}
}

// RemovedDeployments returns the removed IDs of the "deployments" edge to the Deployment entity.
func (m *AgentMutation) RemovedDeploymentsIDs() (ids []int) {
	for id := range m.removeddeployments {
		ids = append(ids, id)
	}
	return
}

// DeploymentsIDs returns the "deployments" edge IDs in the mutation.
func (m *AgentMutation) DeploymentsIDs() (ids []int) {
	for id := range m.deployments {
		ids = append(ids, id)
	}
	return
}

// ResetDeployments resets all changes to the "deployments" edge.
func (m *AgentMutation) ResetDeployments() {
	m.deployments = nil
	m.cleareddeployments = false
	m.removeddeployments = nil
}

// AddUpdateIDs adds the "updates" edge to the Update entity by ids.
func (m *AgentMutation) AddUpdateIDs(ids ...int) {
	if m.updates == nil {
		m.updates = make(map[int]struct{})
	}
	for i := range ids {
		m.updates[ids[i]] = struct{}{}
	}
}

// ClearUpdates clears the "updates" edge to the Update entity.
func (m *AgentMutation) ClearUpdates() {
	m.clearedupdates = true
}

// UpdatesCleared reports if the "updates" edge to the Update entity was cleared.
func (m *AgentMutation) UpdatesCleared() bool {
	return m.clearedupdates
}

// RemoveUpdateIDs removes the "updates" edge to the Update entity by IDs.
func (m *AgentMutation) RemoveUpdateIDs(ids ...int) {
	if m.removedupdates == nil {
		m.removedupdates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.updates, ids[i])
		m.removedupdates[ids[i]] = struct{}{}
	}
}

// RemovedUpdates returns the removed IDs of the "updates" edge to the Update entity.
func (m *AgentMutation) RemovedUpdatesIDs() (ids []int) {
	for id := range m.removedupdates {
		ids = append(ids, id)
	}
	return
}

// UpdatesIDs returns the "updates" edge IDs in the mutation.
func (m *AgentMutation) UpdatesIDs() (ids []int) {
	for id := range m.updates {
		ids = append(ids, id)
	}
	return
}

// ResetUpdates resets all changes to the "updates" edge.
func (m *AgentMutation) ResetUpdates() {
	m.updates = nil
	m.clearedupdates = false
	m.removedupdates = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *AgentMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *AgentMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *AgentMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *AgentMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *AgentMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *AgentMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *AgentMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *AgentMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *AgentMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *AgentMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *AgentMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *AgentMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *AgentMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *AgentMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *AgentMutation) SetReleaseID(id int) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *AgentMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *AgentMutation) ReleaseCleared() bool {
	return m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *AgentMutation) ReleaseID() (id int, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) ReleaseIDs() (ids []int) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *AgentMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.os != nil {
		fields = append(fields, agent.FieldOs)
	}
	if m.hostname != nil {
		fields = append(fields, agent.FieldHostname)
	}
	if m.ip != nil {
		fields = append(fields, agent.FieldIP)
	}
	if m.mac != nil {
		fields = append(fields, agent.FieldMAC)
	}
	if m.first_contact != nil {
		fields = append(fields, agent.FieldFirstContact)
	}
	if m.last_contact != nil {
		fields = append(fields, agent.FieldLastContact)
	}
	if m.vnc != nil {
		fields = append(fields, agent.FieldVnc)
	}
	if m.notes != nil {
		fields = append(fields, agent.FieldNotes)
	}
	if m.update_task_status != nil {
		fields = append(fields, agent.FieldUpdateTaskStatus)
	}
	if m.update_task_description != nil {
		fields = append(fields, agent.FieldUpdateTaskDescription)
	}
	if m.update_task_result != nil {
		fields = append(fields, agent.FieldUpdateTaskResult)
	}
	if m.update_task_execution != nil {
		fields = append(fields, agent.FieldUpdateTaskExecution)
	}
	if m.update_task_version != nil {
		fields = append(fields, agent.FieldUpdateTaskVersion)
	}
	if m.vnc_proxy_port != nil {
		fields = append(fields, agent.FieldVncProxyPort)
	}
	if m.sftp_port != nil {
		fields = append(fields, agent.FieldSftpPort)
	}
	if m.status != nil {
		fields = append(fields, agent.FieldStatus)
	}
	if m.certificate_ready != nil {
		fields = append(fields, agent.FieldCertificateReady)
	}
	if m.restart_required != nil {
		fields = append(fields, agent.FieldRestartRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldOs:
		return m.Os()
	case agent.FieldHostname:
		return m.Hostname()
	case agent.FieldIP:
		return m.IP()
	case agent.FieldMAC:
		return m.MAC()
	case agent.FieldFirstContact:
		return m.FirstContact()
	case agent.FieldLastContact:
		return m.LastContact()
	case agent.FieldVnc:
		return m.Vnc()
	case agent.FieldNotes:
		return m.Notes()
	case agent.FieldUpdateTaskStatus:
		return m.UpdateTaskStatus()
	case agent.FieldUpdateTaskDescription:
		return m.UpdateTaskDescription()
	case agent.FieldUpdateTaskResult:
		return m.UpdateTaskResult()
	case agent.FieldUpdateTaskExecution:
		return m.UpdateTaskExecution()
	case agent.FieldUpdateTaskVersion:
		return m.UpdateTaskVersion()
	case agent.FieldVncProxyPort:
		return m.VncProxyPort()
	case agent.FieldSftpPort:
		return m.SftpPort()
	case agent.FieldStatus:
		return m.Status()
	case agent.FieldCertificateReady:
		return m.CertificateReady()
	case agent.FieldRestartRequired:
		return m.RestartRequired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldOs:
		return m.OldOs(ctx)
	case agent.FieldHostname:
		return m.OldHostname(ctx)
	case agent.FieldIP:
		return m.OldIP(ctx)
	case agent.FieldMAC:
		return m.OldMAC(ctx)
	case agent.FieldFirstContact:
		return m.OldFirstContact(ctx)
	case agent.FieldLastContact:
		return m.OldLastContact(ctx)
	case agent.FieldVnc:
		return m.OldVnc(ctx)
	case agent.FieldNotes:
		return m.OldNotes(ctx)
	case agent.FieldUpdateTaskStatus:
		return m.OldUpdateTaskStatus(ctx)
	case agent.FieldUpdateTaskDescription:
		return m.OldUpdateTaskDescription(ctx)
	case agent.FieldUpdateTaskResult:
		return m.OldUpdateTaskResult(ctx)
	case agent.FieldUpdateTaskExecution:
		return m.OldUpdateTaskExecution(ctx)
	case agent.FieldUpdateTaskVersion:
		return m.OldUpdateTaskVersion(ctx)
	case agent.FieldVncProxyPort:
		return m.OldVncProxyPort(ctx)
	case agent.FieldSftpPort:
		return m.OldSftpPort(ctx)
	case agent.FieldStatus:
		return m.OldStatus(ctx)
	case agent.FieldCertificateReady:
		return m.OldCertificateReady(ctx)
	case agent.FieldRestartRequired:
		return m.OldRestartRequired(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agent.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agent.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case agent.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case agent.FieldFirstContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstContact(v)
		return nil
	case agent.FieldLastContact:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastContact(v)
		return nil
	case agent.FieldVnc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVnc(v)
		return nil
	case agent.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case agent.FieldUpdateTaskStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskStatus(v)
		return nil
	case agent.FieldUpdateTaskDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskDescription(v)
		return nil
	case agent.FieldUpdateTaskResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskResult(v)
		return nil
	case agent.FieldUpdateTaskExecution:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskExecution(v)
		return nil
	case agent.FieldUpdateTaskVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTaskVersion(v)
		return nil
	case agent.FieldVncProxyPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVncProxyPort(v)
		return nil
	case agent.FieldSftpPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSftpPort(v)
		return nil
	case agent.FieldStatus:
		v, ok := value.(agent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agent.FieldCertificateReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateReady(v)
		return nil
	case agent.FieldRestartRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestartRequired(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldFirstContact) {
		fields = append(fields, agent.FieldFirstContact)
	}
	if m.FieldCleared(agent.FieldLastContact) {
		fields = append(fields, agent.FieldLastContact)
	}
	if m.FieldCleared(agent.FieldVnc) {
		fields = append(fields, agent.FieldVnc)
	}
	if m.FieldCleared(agent.FieldNotes) {
		fields = append(fields, agent.FieldNotes)
	}
	if m.FieldCleared(agent.FieldUpdateTaskStatus) {
		fields = append(fields, agent.FieldUpdateTaskStatus)
	}
	if m.FieldCleared(agent.FieldUpdateTaskDescription) {
		fields = append(fields, agent.FieldUpdateTaskDescription)
	}
	if m.FieldCleared(agent.FieldUpdateTaskResult) {
		fields = append(fields, agent.FieldUpdateTaskResult)
	}
	if m.FieldCleared(agent.FieldUpdateTaskExecution) {
		fields = append(fields, agent.FieldUpdateTaskExecution)
	}
	if m.FieldCleared(agent.FieldUpdateTaskVersion) {
		fields = append(fields, agent.FieldUpdateTaskVersion)
	}
	if m.FieldCleared(agent.FieldVncProxyPort) {
		fields = append(fields, agent.FieldVncProxyPort)
	}
	if m.FieldCleared(agent.FieldSftpPort) {
		fields = append(fields, agent.FieldSftpPort)
	}
	if m.FieldCleared(agent.FieldStatus) {
		fields = append(fields, agent.FieldStatus)
	}
	if m.FieldCleared(agent.FieldCertificateReady) {
		fields = append(fields, agent.FieldCertificateReady)
	}
	if m.FieldCleared(agent.FieldRestartRequired) {
		fields = append(fields, agent.FieldRestartRequired)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldFirstContact:
		m.ClearFirstContact()
		return nil
	case agent.FieldLastContact:
		m.ClearLastContact()
		return nil
	case agent.FieldVnc:
		m.ClearVnc()
		return nil
	case agent.FieldNotes:
		m.ClearNotes()
		return nil
	case agent.FieldUpdateTaskStatus:
		m.ClearUpdateTaskStatus()
		return nil
	case agent.FieldUpdateTaskDescription:
		m.ClearUpdateTaskDescription()
		return nil
	case agent.FieldUpdateTaskResult:
		m.ClearUpdateTaskResult()
		return nil
	case agent.FieldUpdateTaskExecution:
		m.ClearUpdateTaskExecution()
		return nil
	case agent.FieldUpdateTaskVersion:
		m.ClearUpdateTaskVersion()
		return nil
	case agent.FieldVncProxyPort:
		m.ClearVncProxyPort()
		return nil
	case agent.FieldSftpPort:
		m.ClearSftpPort()
		return nil
	case agent.FieldStatus:
		m.ClearStatus()
		return nil
	case agent.FieldCertificateReady:
		m.ClearCertificateReady()
		return nil
	case agent.FieldRestartRequired:
		m.ClearRestartRequired()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldOs:
		m.ResetOs()
		return nil
	case agent.FieldHostname:
		m.ResetHostname()
		return nil
	case agent.FieldIP:
		m.ResetIP()
		return nil
	case agent.FieldMAC:
		m.ResetMAC()
		return nil
	case agent.FieldFirstContact:
		m.ResetFirstContact()
		return nil
	case agent.FieldLastContact:
		m.ResetLastContact()
		return nil
	case agent.FieldVnc:
		m.ResetVnc()
		return nil
	case agent.FieldNotes:
		m.ResetNotes()
		return nil
	case agent.FieldUpdateTaskStatus:
		m.ResetUpdateTaskStatus()
		return nil
	case agent.FieldUpdateTaskDescription:
		m.ResetUpdateTaskDescription()
		return nil
	case agent.FieldUpdateTaskResult:
		m.ResetUpdateTaskResult()
		return nil
	case agent.FieldUpdateTaskExecution:
		m.ResetUpdateTaskExecution()
		return nil
	case agent.FieldUpdateTaskVersion:
		m.ResetUpdateTaskVersion()
		return nil
	case agent.FieldVncProxyPort:
		m.ResetVncProxyPort()
		return nil
	case agent.FieldSftpPort:
		m.ResetSftpPort()
		return nil
	case agent.FieldStatus:
		m.ResetStatus()
		return nil
	case agent.FieldCertificateReady:
		m.ResetCertificateReady()
		return nil
	case agent.FieldRestartRequired:
		m.ResetRestartRequired()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.computer != nil {
		edges = append(edges, agent.EdgeComputer)
	}
	if m.operatingsystem != nil {
		edges = append(edges, agent.EdgeOperatingsystem)
	}
	if m.systemupdate != nil {
		edges = append(edges, agent.EdgeSystemupdate)
	}
	if m.antivirus != nil {
		edges = append(edges, agent.EdgeAntivirus)
	}
	if m.logicaldisks != nil {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.apps != nil {
		edges = append(edges, agent.EdgeApps)
	}
	if m.monitors != nil {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.shares != nil {
		edges = append(edges, agent.EdgeShares)
	}
	if m.printers != nil {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.networkadapters != nil {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.deployments != nil {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.updates != nil {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.tags != nil {
		edges = append(edges, agent.EdgeTags)
	}
	if m.metadata != nil {
		edges = append(edges, agent.EdgeMetadata)
	}
	if m.release != nil {
		edges = append(edges, agent.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeComputer:
		if id := m.computer; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeOperatingsystem:
		if id := m.operatingsystem; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeSystemupdate:
		if id := m.systemupdate; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeAntivirus:
		if id := m.antivirus; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeLogicaldisks:
		ids := make([]ent.Value, 0, len(m.logicaldisks))
		for id := range m.logicaldisks {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMonitors:
		ids := make([]ent.Value, 0, len(m.monitors))
		for id := range m.monitors {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePrinters:
		ids := make([]ent.Value, 0, len(m.printers))
		for id := range m.printers {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeNetworkadapters:
		ids := make([]ent.Value, 0, len(m.networkadapters))
		for id := range m.networkadapters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.deployments))
		for id := range m.deployments {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.updates))
		for id := range m.updates {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedlogicaldisks != nil {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.removedapps != nil {
		edges = append(edges, agent.EdgeApps)
	}
	if m.removedmonitors != nil {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.removedshares != nil {
		edges = append(edges, agent.EdgeShares)
	}
	if m.removedprinters != nil {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.removednetworkadapters != nil {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.removeddeployments != nil {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.removedupdates != nil {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.removedtags != nil {
		edges = append(edges, agent.EdgeTags)
	}
	if m.removedmetadata != nil {
		edges = append(edges, agent.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeLogicaldisks:
		ids := make([]ent.Value, 0, len(m.removedlogicaldisks))
		for id := range m.removedlogicaldisks {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMonitors:
		ids := make([]ent.Value, 0, len(m.removedmonitors))
		for id := range m.removedmonitors {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgePrinters:
		ids := make([]ent.Value, 0, len(m.removedprinters))
		for id := range m.removedprinters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeNetworkadapters:
		ids := make([]ent.Value, 0, len(m.removednetworkadapters))
		for id := range m.removednetworkadapters {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeDeployments:
		ids := make([]ent.Value, 0, len(m.removeddeployments))
		for id := range m.removeddeployments {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeUpdates:
		ids := make([]ent.Value, 0, len(m.removedupdates))
		for id := range m.removedupdates {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedcomputer {
		edges = append(edges, agent.EdgeComputer)
	}
	if m.clearedoperatingsystem {
		edges = append(edges, agent.EdgeOperatingsystem)
	}
	if m.clearedsystemupdate {
		edges = append(edges, agent.EdgeSystemupdate)
	}
	if m.clearedantivirus {
		edges = append(edges, agent.EdgeAntivirus)
	}
	if m.clearedlogicaldisks {
		edges = append(edges, agent.EdgeLogicaldisks)
	}
	if m.clearedapps {
		edges = append(edges, agent.EdgeApps)
	}
	if m.clearedmonitors {
		edges = append(edges, agent.EdgeMonitors)
	}
	if m.clearedshares {
		edges = append(edges, agent.EdgeShares)
	}
	if m.clearedprinters {
		edges = append(edges, agent.EdgePrinters)
	}
	if m.clearednetworkadapters {
		edges = append(edges, agent.EdgeNetworkadapters)
	}
	if m.cleareddeployments {
		edges = append(edges, agent.EdgeDeployments)
	}
	if m.clearedupdates {
		edges = append(edges, agent.EdgeUpdates)
	}
	if m.clearedtags {
		edges = append(edges, agent.EdgeTags)
	}
	if m.clearedmetadata {
		edges = append(edges, agent.EdgeMetadata)
	}
	if m.clearedrelease {
		edges = append(edges, agent.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeComputer:
		return m.clearedcomputer
	case agent.EdgeOperatingsystem:
		return m.clearedoperatingsystem
	case agent.EdgeSystemupdate:
		return m.clearedsystemupdate
	case agent.EdgeAntivirus:
		return m.clearedantivirus
	case agent.EdgeLogicaldisks:
		return m.clearedlogicaldisks
	case agent.EdgeApps:
		return m.clearedapps
	case agent.EdgeMonitors:
		return m.clearedmonitors
	case agent.EdgeShares:
		return m.clearedshares
	case agent.EdgePrinters:
		return m.clearedprinters
	case agent.EdgeNetworkadapters:
		return m.clearednetworkadapters
	case agent.EdgeDeployments:
		return m.cleareddeployments
	case agent.EdgeUpdates:
		return m.clearedupdates
	case agent.EdgeTags:
		return m.clearedtags
	case agent.EdgeMetadata:
		return m.clearedmetadata
	case agent.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeComputer:
		m.ClearComputer()
		return nil
	case agent.EdgeOperatingsystem:
		m.ClearOperatingsystem()
		return nil
	case agent.EdgeSystemupdate:
		m.ClearSystemupdate()
		return nil
	case agent.EdgeAntivirus:
		m.ClearAntivirus()
		return nil
	case agent.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeComputer:
		m.ResetComputer()
		return nil
	case agent.EdgeOperatingsystem:
		m.ResetOperatingsystem()
		return nil
	case agent.EdgeSystemupdate:
		m.ResetSystemupdate()
		return nil
	case agent.EdgeAntivirus:
		m.ResetAntivirus()
		return nil
	case agent.EdgeLogicaldisks:
		m.ResetLogicaldisks()
		return nil
	case agent.EdgeApps:
		m.ResetApps()
		return nil
	case agent.EdgeMonitors:
		m.ResetMonitors()
		return nil
	case agent.EdgeShares:
		m.ResetShares()
		return nil
	case agent.EdgePrinters:
		m.ResetPrinters()
		return nil
	case agent.EdgeNetworkadapters:
		m.ResetNetworkadapters()
		return nil
	case agent.EdgeDeployments:
		m.ResetDeployments()
		return nil
	case agent.EdgeUpdates:
		m.ResetUpdates()
		return nil
	case agent.EdgeTags:
		m.ResetTags()
		return nil
	case agent.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case agent.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AntivirusMutation represents an operation that mutates the Antivirus nodes in the graph.
type AntivirusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	is_active     *bool
	is_updated    *bool
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Antivirus, error)
	predicates    []predicate.Antivirus
}

var _ ent.Mutation = (*AntivirusMutation)(nil)

// antivirusOption allows management of the mutation configuration using functional options.
type antivirusOption func(*AntivirusMutation)

// newAntivirusMutation creates new mutation for the Antivirus entity.
func newAntivirusMutation(c config, op Op, opts ...antivirusOption) *AntivirusMutation {
	m := &AntivirusMutation{
		config:        c,
		op:            op,
		typ:           TypeAntivirus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAntivirusID sets the ID field of the mutation.
func withAntivirusID(id int) antivirusOption {
	return func(m *AntivirusMutation) {
		var (
			err   error
			once  sync.Once
			value *Antivirus
		)
		m.oldValue = func(ctx context.Context) (*Antivirus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Antivirus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAntivirus sets the old Antivirus of the mutation.
func withAntivirus(node *Antivirus) antivirusOption {
	return func(m *AntivirusMutation) {
		m.oldValue = func(context.Context) (*Antivirus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AntivirusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AntivirusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AntivirusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AntivirusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Antivirus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AntivirusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AntivirusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AntivirusMutation) ResetName() {
	m.name = nil
}

// SetIsActive sets the "is_active" field.
func (m *AntivirusMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AntivirusMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AntivirusMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsUpdated sets the "is_updated" field.
func (m *AntivirusMutation) SetIsUpdated(b bool) {
	m.is_updated = &b
}

// IsUpdated returns the value of the "is_updated" field in the mutation.
func (m *AntivirusMutation) IsUpdated() (r bool, exists bool) {
	v := m.is_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUpdated returns the old "is_updated" field's value of the Antivirus entity.
// If the Antivirus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AntivirusMutation) OldIsUpdated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUpdated: %w", err)
	}
	return oldValue.IsUpdated, nil
}

// ResetIsUpdated resets all changes to the "is_updated" field.
func (m *AntivirusMutation) ResetIsUpdated() {
	m.is_updated = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *AntivirusMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *AntivirusMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *AntivirusMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AntivirusMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AntivirusMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AntivirusMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AntivirusMutation builder.
func (m *AntivirusMutation) Where(ps ...predicate.Antivirus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AntivirusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AntivirusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Antivirus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AntivirusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AntivirusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Antivirus).
func (m *AntivirusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AntivirusMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, antivirus.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, antivirus.FieldIsActive)
	}
	if m.is_updated != nil {
		fields = append(fields, antivirus.FieldIsUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AntivirusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case antivirus.FieldName:
		return m.Name()
	case antivirus.FieldIsActive:
		return m.IsActive()
	case antivirus.FieldIsUpdated:
		return m.IsUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AntivirusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case antivirus.FieldName:
		return m.OldName(ctx)
	case antivirus.FieldIsActive:
		return m.OldIsActive(ctx)
	case antivirus.FieldIsUpdated:
		return m.OldIsUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Antivirus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AntivirusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case antivirus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case antivirus.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case antivirus.FieldIsUpdated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Antivirus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AntivirusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AntivirusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AntivirusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Antivirus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AntivirusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AntivirusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AntivirusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Antivirus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AntivirusMutation) ResetField(name string) error {
	switch name {
	case antivirus.FieldName:
		m.ResetName()
		return nil
	case antivirus.FieldIsActive:
		m.ResetIsActive()
		return nil
	case antivirus.FieldIsUpdated:
		m.ResetIsUpdated()
		return nil
	}
	return fmt.Errorf("unknown Antivirus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AntivirusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, antivirus.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AntivirusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case antivirus.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AntivirusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AntivirusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AntivirusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, antivirus.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AntivirusMutation) EdgeCleared(name string) bool {
	switch name {
	case antivirus.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AntivirusMutation) ClearEdge(name string) error {
	switch name {
	case antivirus.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Antivirus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AntivirusMutation) ResetEdge(name string) error {
	switch name {
	case antivirus.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Antivirus edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	version       *string
	publisher     *string
	install_date  *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *AppMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AppMutation) ResetVersion() {
	m.version = nil
}

// SetPublisher sets the "publisher" field.
func (m *AppMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[app.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[app.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, app.FieldPublisher)
}

// SetInstallDate sets the "install_date" field.
func (m *AppMutation) SetInstallDate(s string) {
	m.install_date = &s
}

// InstallDate returns the value of the "install_date" field in the mutation.
func (m *AppMutation) InstallDate() (r string, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old "install_date" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldInstallDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of the "install_date" field.
func (m *AppMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[app.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the "install_date" field was cleared in this mutation.
func (m *AppMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[app.FieldInstallDate]
	return ok
}

// ResetInstallDate resets all changes to the "install_date" field.
func (m *AppMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, app.FieldInstallDate)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *AppMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *AppMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *AppMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AppMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.version != nil {
		fields = append(fields, app.FieldVersion)
	}
	if m.publisher != nil {
		fields = append(fields, app.FieldPublisher)
	}
	if m.install_date != nil {
		fields = append(fields, app.FieldInstallDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldName:
		return m.Name()
	case app.FieldVersion:
		return m.Version()
	case app.FieldPublisher:
		return m.Publisher()
	case app.FieldInstallDate:
		return m.InstallDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldVersion:
		return m.OldVersion(ctx)
	case app.FieldPublisher:
		return m.OldPublisher(ctx)
	case app.FieldInstallDate:
		return m.OldInstallDate(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case app.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case app.FieldInstallDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldPublisher) {
		fields = append(fields, app.FieldPublisher)
	}
	if m.FieldCleared(app.FieldInstallDate) {
		fields = append(fields, app.FieldInstallDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldPublisher:
		m.ClearPublisher()
		return nil
	case app.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldVersion:
		m.ResetVersion()
		return nil
	case app.FieldPublisher:
		m.ResetPublisher()
		return nil
	case app.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, app.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, app.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// CertificateMutation represents an operation that mutates the Certificate nodes in the graph.
type CertificateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	_type         *certificate.Type
	description   *string
	expiry        *time.Time
	uid           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Certificate, error)
	predicates    []predicate.Certificate
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows management of the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for the Certificate entity.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the ID field of the mutation.
func withCertificateID(id int64) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Certificate entities.
func (m *CertificateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertificateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertificateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Certificate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *CertificateMutation) SetType(c certificate.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CertificateMutation) GetType() (r certificate.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldType(ctx context.Context) (v certificate.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CertificateMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *CertificateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CertificateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CertificateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[certificate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CertificateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[certificate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CertificateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, certificate.FieldDescription)
}

// SetExpiry sets the "expiry" field.
func (m *CertificateMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *CertificateMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *CertificateMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[certificate.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *CertificateMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[certificate.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *CertificateMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, certificate.FieldExpiry)
}

// SetUID sets the "uid" field.
func (m *CertificateMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *CertificateMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Certificate entity.
// If the Certificate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertificateMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *CertificateMutation) ClearUID() {
	m.uid = nil
	m.clearedFields[certificate.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *CertificateMutation) UIDCleared() bool {
	_, ok := m.clearedFields[certificate.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *CertificateMutation) ResetUID() {
	m.uid = nil
	delete(m.clearedFields, certificate.FieldUID)
}

// Where appends a list predicates to the CertificateMutation builder.
func (m *CertificateMutation) Where(ps ...predicate.Certificate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CertificateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CertificateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Certificate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CertificateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, certificate.FieldType)
	}
	if m.description != nil {
		fields = append(fields, certificate.FieldDescription)
	}
	if m.expiry != nil {
		fields = append(fields, certificate.FieldExpiry)
	}
	if m.uid != nil {
		fields = append(fields, certificate.FieldUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldType:
		return m.GetType()
	case certificate.FieldDescription:
		return m.Description()
	case certificate.FieldExpiry:
		return m.Expiry()
	case certificate.FieldUID:
		return m.UID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldType:
		return m.OldType(ctx)
	case certificate.FieldDescription:
		return m.OldDescription(ctx)
	case certificate.FieldExpiry:
		return m.OldExpiry(ctx)
	case certificate.FieldUID:
		return m.OldUID(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldType:
		v, ok := value.(certificate.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case certificate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case certificate.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case certificate.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertificateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(certificate.FieldDescription) {
		fields = append(fields, certificate.FieldDescription)
	}
	if m.FieldCleared(certificate.FieldExpiry) {
		fields = append(fields, certificate.FieldExpiry)
	}
	if m.FieldCleared(certificate.FieldUID) {
		fields = append(fields, certificate.FieldUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	switch name {
	case certificate.FieldDescription:
		m.ClearDescription()
		return nil
	case certificate.FieldExpiry:
		m.ClearExpiry()
		return nil
	case certificate.FieldUID:
		m.ClearUID()
		return nil
	}
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldType:
		m.ResetType()
		return nil
	case certificate.FieldDescription:
		m.ResetDescription()
		return nil
	case certificate.FieldExpiry:
		m.ResetExpiry()
		return nil
	case certificate.FieldUID:
		m.ResetUID()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	hostname       *string
	arch           *string
	os             *string
	component      *component.Component
	version        *string
	channel        *component.Channel
	update_status  *component.UpdateStatus
	update_message *string
	update_when    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Component, error)
	predicates     []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id int) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComponentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Component.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *ComponentMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *ComponentMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *ComponentMutation) ResetHostname() {
	m.hostname = nil
}

// SetArch sets the "arch" field.
func (m *ComponentMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *ComponentMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ResetArch resets all changes to the "arch" field.
func (m *ComponentMutation) ResetArch() {
	m.arch = nil
}

// SetOs sets the "os" field.
func (m *ComponentMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *ComponentMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *ComponentMutation) ResetOs() {
	m.os = nil
}

// SetComponent sets the "component" field.
func (m *ComponentMutation) SetComponent(c component.Component) {
	m.component = &c
}

// Component returns the value of the "component" field in the mutation.
func (m *ComponentMutation) Component() (r component.Component, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldComponent(ctx context.Context) (v component.Component, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent resets all changes to the "component" field.
func (m *ComponentMutation) ResetComponent() {
	m.component = nil
}

// SetVersion sets the "version" field.
func (m *ComponentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ComponentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ComponentMutation) ResetVersion() {
	m.version = nil
}

// SetChannel sets the "channel" field.
func (m *ComponentMutation) SetChannel(c component.Channel) {
	m.channel = &c
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ComponentMutation) Channel() (r component.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldChannel(ctx context.Context) (v component.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *ComponentMutation) ResetChannel() {
	m.channel = nil
}

// SetUpdateStatus sets the "update_status" field.
func (m *ComponentMutation) SetUpdateStatus(cs component.UpdateStatus) {
	m.update_status = &cs
}

// UpdateStatus returns the value of the "update_status" field in the mutation.
func (m *ComponentMutation) UpdateStatus() (r component.UpdateStatus, exists bool) {
	v := m.update_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateStatus returns the old "update_status" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldUpdateStatus(ctx context.Context) (v component.UpdateStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateStatus: %w", err)
	}
	return oldValue.UpdateStatus, nil
}

// ClearUpdateStatus clears the value of the "update_status" field.
func (m *ComponentMutation) ClearUpdateStatus() {
	m.update_status = nil
	m.clearedFields[component.FieldUpdateStatus] = struct{}{}
}

// UpdateStatusCleared returns if the "update_status" field was cleared in this mutation.
func (m *ComponentMutation) UpdateStatusCleared() bool {
	_, ok := m.clearedFields[component.FieldUpdateStatus]
	return ok
}

// ResetUpdateStatus resets all changes to the "update_status" field.
func (m *ComponentMutation) ResetUpdateStatus() {
	m.update_status = nil
	delete(m.clearedFields, component.FieldUpdateStatus)
}

// SetUpdateMessage sets the "update_message" field.
func (m *ComponentMutation) SetUpdateMessage(s string) {
	m.update_message = &s
}

// UpdateMessage returns the value of the "update_message" field in the mutation.
func (m *ComponentMutation) UpdateMessage() (r string, exists bool) {
	v := m.update_message
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateMessage returns the old "update_message" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldUpdateMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateMessage: %w", err)
	}
	return oldValue.UpdateMessage, nil
}

// ClearUpdateMessage clears the value of the "update_message" field.
func (m *ComponentMutation) ClearUpdateMessage() {
	m.update_message = nil
	m.clearedFields[component.FieldUpdateMessage] = struct{}{}
}

// UpdateMessageCleared returns if the "update_message" field was cleared in this mutation.
func (m *ComponentMutation) UpdateMessageCleared() bool {
	_, ok := m.clearedFields[component.FieldUpdateMessage]
	return ok
}

// ResetUpdateMessage resets all changes to the "update_message" field.
func (m *ComponentMutation) ResetUpdateMessage() {
	m.update_message = nil
	delete(m.clearedFields, component.FieldUpdateMessage)
}

// SetUpdateWhen sets the "update_when" field.
func (m *ComponentMutation) SetUpdateWhen(t time.Time) {
	m.update_when = &t
}

// UpdateWhen returns the value of the "update_when" field in the mutation.
func (m *ComponentMutation) UpdateWhen() (r time.Time, exists bool) {
	v := m.update_when
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateWhen returns the old "update_when" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldUpdateWhen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateWhen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateWhen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateWhen: %w", err)
	}
	return oldValue.UpdateWhen, nil
}

// ClearUpdateWhen clears the value of the "update_when" field.
func (m *ComponentMutation) ClearUpdateWhen() {
	m.update_when = nil
	m.clearedFields[component.FieldUpdateWhen] = struct{}{}
}

// UpdateWhenCleared returns if the "update_when" field was cleared in this mutation.
func (m *ComponentMutation) UpdateWhenCleared() bool {
	_, ok := m.clearedFields[component.FieldUpdateWhen]
	return ok
}

// ResetUpdateWhen resets all changes to the "update_when" field.
func (m *ComponentMutation) ResetUpdateWhen() {
	m.update_when = nil
	delete(m.clearedFields, component.FieldUpdateWhen)
}

// Where appends a list predicates to the ComponentMutation builder.
func (m *ComponentMutation) Where(ps ...predicate.Component) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Component, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hostname != nil {
		fields = append(fields, component.FieldHostname)
	}
	if m.arch != nil {
		fields = append(fields, component.FieldArch)
	}
	if m.os != nil {
		fields = append(fields, component.FieldOs)
	}
	if m.component != nil {
		fields = append(fields, component.FieldComponent)
	}
	if m.version != nil {
		fields = append(fields, component.FieldVersion)
	}
	if m.channel != nil {
		fields = append(fields, component.FieldChannel)
	}
	if m.update_status != nil {
		fields = append(fields, component.FieldUpdateStatus)
	}
	if m.update_message != nil {
		fields = append(fields, component.FieldUpdateMessage)
	}
	if m.update_when != nil {
		fields = append(fields, component.FieldUpdateWhen)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldHostname:
		return m.Hostname()
	case component.FieldArch:
		return m.Arch()
	case component.FieldOs:
		return m.Os()
	case component.FieldComponent:
		return m.Component()
	case component.FieldVersion:
		return m.Version()
	case component.FieldChannel:
		return m.Channel()
	case component.FieldUpdateStatus:
		return m.UpdateStatus()
	case component.FieldUpdateMessage:
		return m.UpdateMessage()
	case component.FieldUpdateWhen:
		return m.UpdateWhen()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldHostname:
		return m.OldHostname(ctx)
	case component.FieldArch:
		return m.OldArch(ctx)
	case component.FieldOs:
		return m.OldOs(ctx)
	case component.FieldComponent:
		return m.OldComponent(ctx)
	case component.FieldVersion:
		return m.OldVersion(ctx)
	case component.FieldChannel:
		return m.OldChannel(ctx)
	case component.FieldUpdateStatus:
		return m.OldUpdateStatus(ctx)
	case component.FieldUpdateMessage:
		return m.OldUpdateMessage(ctx)
	case component.FieldUpdateWhen:
		return m.OldUpdateWhen(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case component.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case component.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case component.FieldComponent:
		v, ok := value.(component.Component)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case component.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case component.FieldChannel:
		v, ok := value.(component.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case component.FieldUpdateStatus:
		v, ok := value.(component.UpdateStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateStatus(v)
		return nil
	case component.FieldUpdateMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateMessage(v)
		return nil
	case component.FieldUpdateWhen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateWhen(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(component.FieldUpdateStatus) {
		fields = append(fields, component.FieldUpdateStatus)
	}
	if m.FieldCleared(component.FieldUpdateMessage) {
		fields = append(fields, component.FieldUpdateMessage)
	}
	if m.FieldCleared(component.FieldUpdateWhen) {
		fields = append(fields, component.FieldUpdateWhen)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	switch name {
	case component.FieldUpdateStatus:
		m.ClearUpdateStatus()
		return nil
	case component.FieldUpdateMessage:
		m.ClearUpdateMessage()
		return nil
	case component.FieldUpdateWhen:
		m.ClearUpdateWhen()
		return nil
	}
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldHostname:
		m.ResetHostname()
		return nil
	case component.FieldArch:
		m.ResetArch()
		return nil
	case component.FieldOs:
		m.ResetOs()
		return nil
	case component.FieldComponent:
		m.ResetComponent()
		return nil
	case component.FieldVersion:
		m.ResetVersion()
		return nil
	case component.FieldChannel:
		m.ResetChannel()
		return nil
	case component.FieldUpdateStatus:
		m.ResetUpdateStatus()
		return nil
	case component.FieldUpdateMessage:
		m.ResetUpdateMessage()
		return nil
	case component.FieldUpdateWhen:
		m.ResetUpdateWhen()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Component edge %s", name)
}

// ComputerMutation represents an operation that mutates the Computer nodes in the graph.
type ComputerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	manufacturer       *string
	model              *string
	serial             *string
	memory             *uint64
	addmemory          *int64
	processor          *string
	processor_cores    *int64
	addprocessor_cores *int64
	processor_arch     *string
	clearedFields      map[string]struct{}
	owner              *string
	clearedowner       bool
	done               bool
	oldValue           func(context.Context) (*Computer, error)
	predicates         []predicate.Computer
}

var _ ent.Mutation = (*ComputerMutation)(nil)

// computerOption allows management of the mutation configuration using functional options.
type computerOption func(*ComputerMutation)

// newComputerMutation creates new mutation for the Computer entity.
func newComputerMutation(c config, op Op, opts ...computerOption) *ComputerMutation {
	m := &ComputerMutation{
		config:        c,
		op:            op,
		typ:           TypeComputer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComputerID sets the ID field of the mutation.
func withComputerID(id int) computerOption {
	return func(m *ComputerMutation) {
		var (
			err   error
			once  sync.Once
			value *Computer
		)
		m.oldValue = func(ctx context.Context) (*Computer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Computer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComputer sets the old Computer of the mutation.
func withComputer(node *Computer) computerOption {
	return func(m *ComputerMutation) {
		m.oldValue = func(context.Context) (*Computer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComputerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComputerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComputerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComputerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Computer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManufacturer sets the "manufacturer" field.
func (m *ComputerMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *ComputerMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *ComputerMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[computer.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *ComputerMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[computer.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *ComputerMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, computer.FieldManufacturer)
}

// SetModel sets the "model" field.
func (m *ComputerMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ComputerMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ComputerMutation) ClearModel() {
	m.model = nil
	m.clearedFields[computer.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ComputerMutation) ModelCleared() bool {
	_, ok := m.clearedFields[computer.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ComputerMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, computer.FieldModel)
}

// SetSerial sets the "serial" field.
func (m *ComputerMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *ComputerMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *ComputerMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[computer.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *ComputerMutation) SerialCleared() bool {
	_, ok := m.clearedFields[computer.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *ComputerMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, computer.FieldSerial)
}

// SetMemory sets the "memory" field.
func (m *ComputerMutation) SetMemory(u uint64) {
	m.memory = &u
	m.addmemory = nil
}

// Memory returns the value of the "memory" field in the mutation.
func (m *ComputerMutation) Memory() (r uint64, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldMemory(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// AddMemory adds u to the "memory" field.
func (m *ComputerMutation) AddMemory(u int64) {
	if m.addmemory != nil {
		*m.addmemory += u
	} else {
		m.addmemory = &u
	}
}

// AddedMemory returns the value that was added to the "memory" field in this mutation.
func (m *ComputerMutation) AddedMemory() (r int64, exists bool) {
	v := m.addmemory
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemory clears the value of the "memory" field.
func (m *ComputerMutation) ClearMemory() {
	m.memory = nil
	m.addmemory = nil
	m.clearedFields[computer.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *ComputerMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[computer.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *ComputerMutation) ResetMemory() {
	m.memory = nil
	m.addmemory = nil
	delete(m.clearedFields, computer.FieldMemory)
}

// SetProcessor sets the "processor" field.
func (m *ComputerMutation) SetProcessor(s string) {
	m.processor = &s
}

// Processor returns the value of the "processor" field in the mutation.
func (m *ComputerMutation) Processor() (r string, exists bool) {
	v := m.processor
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessor returns the old "processor" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessor: %w", err)
	}
	return oldValue.Processor, nil
}

// ClearProcessor clears the value of the "processor" field.
func (m *ComputerMutation) ClearProcessor() {
	m.processor = nil
	m.clearedFields[computer.FieldProcessor] = struct{}{}
}

// ProcessorCleared returns if the "processor" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessor]
	return ok
}

// ResetProcessor resets all changes to the "processor" field.
func (m *ComputerMutation) ResetProcessor() {
	m.processor = nil
	delete(m.clearedFields, computer.FieldProcessor)
}

// SetProcessorCores sets the "processor_cores" field.
func (m *ComputerMutation) SetProcessorCores(i int64) {
	m.processor_cores = &i
	m.addprocessor_cores = nil
}

// ProcessorCores returns the value of the "processor_cores" field in the mutation.
func (m *ComputerMutation) ProcessorCores() (r int64, exists bool) {
	v := m.processor_cores
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessorCores returns the old "processor_cores" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessorCores(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessorCores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessorCores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessorCores: %w", err)
	}
	return oldValue.ProcessorCores, nil
}

// AddProcessorCores adds i to the "processor_cores" field.
func (m *ComputerMutation) AddProcessorCores(i int64) {
	if m.addprocessor_cores != nil {
		*m.addprocessor_cores += i
	} else {
		m.addprocessor_cores = &i
	}
}

// AddedProcessorCores returns the value that was added to the "processor_cores" field in this mutation.
func (m *ComputerMutation) AddedProcessorCores() (r int64, exists bool) {
	v := m.addprocessor_cores
	if v == nil {
		return
	}
	return *v, true
}

// ClearProcessorCores clears the value of the "processor_cores" field.
func (m *ComputerMutation) ClearProcessorCores() {
	m.processor_cores = nil
	m.addprocessor_cores = nil
	m.clearedFields[computer.FieldProcessorCores] = struct{}{}
}

// ProcessorCoresCleared returns if the "processor_cores" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorCoresCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessorCores]
	return ok
}

// ResetProcessorCores resets all changes to the "processor_cores" field.
func (m *ComputerMutation) ResetProcessorCores() {
	m.processor_cores = nil
	m.addprocessor_cores = nil
	delete(m.clearedFields, computer.FieldProcessorCores)
}

// SetProcessorArch sets the "processor_arch" field.
func (m *ComputerMutation) SetProcessorArch(s string) {
	m.processor_arch = &s
}

// ProcessorArch returns the value of the "processor_arch" field in the mutation.
func (m *ComputerMutation) ProcessorArch() (r string, exists bool) {
	v := m.processor_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessorArch returns the old "processor_arch" field's value of the Computer entity.
// If the Computer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComputerMutation) OldProcessorArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessorArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessorArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessorArch: %w", err)
	}
	return oldValue.ProcessorArch, nil
}

// ClearProcessorArch clears the value of the "processor_arch" field.
func (m *ComputerMutation) ClearProcessorArch() {
	m.processor_arch = nil
	m.clearedFields[computer.FieldProcessorArch] = struct{}{}
}

// ProcessorArchCleared returns if the "processor_arch" field was cleared in this mutation.
func (m *ComputerMutation) ProcessorArchCleared() bool {
	_, ok := m.clearedFields[computer.FieldProcessorArch]
	return ok
}

// ResetProcessorArch resets all changes to the "processor_arch" field.
func (m *ComputerMutation) ResetProcessorArch() {
	m.processor_arch = nil
	delete(m.clearedFields, computer.FieldProcessorArch)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *ComputerMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *ComputerMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *ComputerMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ComputerMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ComputerMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ComputerMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ComputerMutation builder.
func (m *ComputerMutation) Where(ps ...predicate.Computer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComputerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComputerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Computer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComputerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComputerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Computer).
func (m *ComputerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComputerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.manufacturer != nil {
		fields = append(fields, computer.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, computer.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, computer.FieldSerial)
	}
	if m.memory != nil {
		fields = append(fields, computer.FieldMemory)
	}
	if m.processor != nil {
		fields = append(fields, computer.FieldProcessor)
	}
	if m.processor_cores != nil {
		fields = append(fields, computer.FieldProcessorCores)
	}
	if m.processor_arch != nil {
		fields = append(fields, computer.FieldProcessorArch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComputerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case computer.FieldManufacturer:
		return m.Manufacturer()
	case computer.FieldModel:
		return m.Model()
	case computer.FieldSerial:
		return m.Serial()
	case computer.FieldMemory:
		return m.Memory()
	case computer.FieldProcessor:
		return m.Processor()
	case computer.FieldProcessorCores:
		return m.ProcessorCores()
	case computer.FieldProcessorArch:
		return m.ProcessorArch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComputerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case computer.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case computer.FieldModel:
		return m.OldModel(ctx)
	case computer.FieldSerial:
		return m.OldSerial(ctx)
	case computer.FieldMemory:
		return m.OldMemory(ctx)
	case computer.FieldProcessor:
		return m.OldProcessor(ctx)
	case computer.FieldProcessorCores:
		return m.OldProcessorCores(ctx)
	case computer.FieldProcessorArch:
		return m.OldProcessorArch(ctx)
	}
	return nil, fmt.Errorf("unknown Computer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComputerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case computer.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case computer.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case computer.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case computer.FieldMemory:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case computer.FieldProcessor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessor(v)
		return nil
	case computer.FieldProcessorCores:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessorCores(v)
		return nil
	case computer.FieldProcessorArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessorArch(v)
		return nil
	}
	return fmt.Errorf("unknown Computer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComputerMutation) AddedFields() []string {
	var fields []string
	if m.addmemory != nil {
		fields = append(fields, computer.FieldMemory)
	}
	if m.addprocessor_cores != nil {
		fields = append(fields, computer.FieldProcessorCores)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComputerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case computer.FieldMemory:
		return m.AddedMemory()
	case computer.FieldProcessorCores:
		return m.AddedProcessorCores()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComputerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case computer.FieldMemory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemory(v)
		return nil
	case computer.FieldProcessorCores:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessorCores(v)
		return nil
	}
	return fmt.Errorf("unknown Computer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComputerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(computer.FieldManufacturer) {
		fields = append(fields, computer.FieldManufacturer)
	}
	if m.FieldCleared(computer.FieldModel) {
		fields = append(fields, computer.FieldModel)
	}
	if m.FieldCleared(computer.FieldSerial) {
		fields = append(fields, computer.FieldSerial)
	}
	if m.FieldCleared(computer.FieldMemory) {
		fields = append(fields, computer.FieldMemory)
	}
	if m.FieldCleared(computer.FieldProcessor) {
		fields = append(fields, computer.FieldProcessor)
	}
	if m.FieldCleared(computer.FieldProcessorCores) {
		fields = append(fields, computer.FieldProcessorCores)
	}
	if m.FieldCleared(computer.FieldProcessorArch) {
		fields = append(fields, computer.FieldProcessorArch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComputerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComputerMutation) ClearField(name string) error {
	switch name {
	case computer.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case computer.FieldModel:
		m.ClearModel()
		return nil
	case computer.FieldSerial:
		m.ClearSerial()
		return nil
	case computer.FieldMemory:
		m.ClearMemory()
		return nil
	case computer.FieldProcessor:
		m.ClearProcessor()
		return nil
	case computer.FieldProcessorCores:
		m.ClearProcessorCores()
		return nil
	case computer.FieldProcessorArch:
		m.ClearProcessorArch()
		return nil
	}
	return fmt.Errorf("unknown Computer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComputerMutation) ResetField(name string) error {
	switch name {
	case computer.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case computer.FieldModel:
		m.ResetModel()
		return nil
	case computer.FieldSerial:
		m.ResetSerial()
		return nil
	case computer.FieldMemory:
		m.ResetMemory()
		return nil
	case computer.FieldProcessor:
		m.ResetProcessor()
		return nil
	case computer.FieldProcessorCores:
		m.ResetProcessorCores()
		return nil
	case computer.FieldProcessorArch:
		m.ResetProcessorArch()
		return nil
	}
	return fmt.Errorf("unknown Computer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComputerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, computer.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComputerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case computer.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComputerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComputerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComputerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, computer.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComputerMutation) EdgeCleared(name string) bool {
	switch name {
	case computer.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComputerMutation) ClearEdge(name string) error {
	switch name {
	case computer.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Computer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComputerMutation) ResetEdge(name string) error {
	switch name {
	case computer.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Computer edge %s", name)
}

// DeploymentMutation represents an operation that mutates the Deployment nodes in the graph.
type DeploymentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	package_id    *string
	name          *string
	version       *string
	installed     *time.Time
	updated       *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Deployment, error)
	predicates    []predicate.Deployment
}

var _ ent.Mutation = (*DeploymentMutation)(nil)

// deploymentOption allows management of the mutation configuration using functional options.
type deploymentOption func(*DeploymentMutation)

// newDeploymentMutation creates new mutation for the Deployment entity.
func newDeploymentMutation(c config, op Op, opts ...deploymentOption) *DeploymentMutation {
	m := &DeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentID sets the ID field of the mutation.
func withDeploymentID(id int) deploymentOption {
	return func(m *DeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Deployment
		)
		m.oldValue = func(ctx context.Context) (*Deployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeployment sets the old Deployment of the mutation.
func withDeployment(node *Deployment) deploymentOption {
	return func(m *DeploymentMutation) {
		m.oldValue = func(context.Context) (*Deployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPackageID sets the "package_id" field.
func (m *DeploymentMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *DeploymentMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldPackageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *DeploymentMutation) ResetPackageID() {
	m.package_id = nil
}

// SetName sets the "name" field.
func (m *DeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *DeploymentMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DeploymentMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *DeploymentMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[deployment.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *DeploymentMutation) VersionCleared() bool {
	_, ok := m.clearedFields[deployment.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *DeploymentMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, deployment.FieldVersion)
}

// SetInstalled sets the "installed" field.
func (m *DeploymentMutation) SetInstalled(t time.Time) {
	m.installed = &t
}

// Installed returns the value of the "installed" field in the mutation.
func (m *DeploymentMutation) Installed() (r time.Time, exists bool) {
	v := m.installed
	if v == nil {
		return
	}
	return *v, true
}

// OldInstalled returns the old "installed" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldInstalled(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstalled: %w", err)
	}
	return oldValue.Installed, nil
}

// ClearInstalled clears the value of the "installed" field.
func (m *DeploymentMutation) ClearInstalled() {
	m.installed = nil
	m.clearedFields[deployment.FieldInstalled] = struct{}{}
}

// InstalledCleared returns if the "installed" field was cleared in this mutation.
func (m *DeploymentMutation) InstalledCleared() bool {
	_, ok := m.clearedFields[deployment.FieldInstalled]
	return ok
}

// ResetInstalled resets all changes to the "installed" field.
func (m *DeploymentMutation) ResetInstalled() {
	m.installed = nil
	delete(m.clearedFields, deployment.FieldInstalled)
}

// SetUpdated sets the "updated" field.
func (m *DeploymentMutation) SetUpdated(t time.Time) {
	m.updated = &t
}

// Updated returns the value of the "updated" field in the mutation.
func (m *DeploymentMutation) Updated() (r time.Time, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *DeploymentMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[deployment.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *DeploymentMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[deployment.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *DeploymentMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, deployment.FieldUpdated)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *DeploymentMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *DeploymentMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *DeploymentMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DeploymentMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DeploymentMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DeploymentMutation builder.
func (m *DeploymentMutation) Where(ps ...predicate.Deployment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Deployment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Deployment).
func (m *DeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.package_id != nil {
		fields = append(fields, deployment.FieldPackageID)
	}
	if m.name != nil {
		fields = append(fields, deployment.FieldName)
	}
	if m.version != nil {
		fields = append(fields, deployment.FieldVersion)
	}
	if m.installed != nil {
		fields = append(fields, deployment.FieldInstalled)
	}
	if m.updated != nil {
		fields = append(fields, deployment.FieldUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldPackageID:
		return m.PackageID()
	case deployment.FieldName:
		return m.Name()
	case deployment.FieldVersion:
		return m.Version()
	case deployment.FieldInstalled:
		return m.Installed()
	case deployment.FieldUpdated:
		return m.Updated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deployment.FieldPackageID:
		return m.OldPackageID(ctx)
	case deployment.FieldName:
		return m.OldName(ctx)
	case deployment.FieldVersion:
		return m.OldVersion(ctx)
	case deployment.FieldInstalled:
		return m.OldInstalled(ctx)
	case deployment.FieldUpdated:
		return m.OldUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Deployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case deployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deployment.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case deployment.FieldInstalled:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstalled(v)
		return nil
	case deployment.FieldUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Deployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deployment.FieldVersion) {
		fields = append(fields, deployment.FieldVersion)
	}
	if m.FieldCleared(deployment.FieldInstalled) {
		fields = append(fields, deployment.FieldInstalled)
	}
	if m.FieldCleared(deployment.FieldUpdated) {
		fields = append(fields, deployment.FieldUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentMutation) ClearField(name string) error {
	switch name {
	case deployment.FieldVersion:
		m.ClearVersion()
		return nil
	case deployment.FieldInstalled:
		m.ClearInstalled()
		return nil
	case deployment.FieldUpdated:
		m.ClearUpdated()
		return nil
	}
	return fmt.Errorf("unknown Deployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentMutation) ResetField(name string) error {
	switch name {
	case deployment.FieldPackageID:
		m.ResetPackageID()
		return nil
	case deployment.FieldName:
		m.ResetName()
		return nil
	case deployment.FieldVersion:
		m.ResetVersion()
		return nil
	case deployment.FieldInstalled:
		m.ResetInstalled()
		return nil
	case deployment.FieldUpdated:
		m.ResetUpdated()
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, deployment.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, deployment.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case deployment.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentMutation) ClearEdge(name string) error {
	switch name {
	case deployment.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Deployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentMutation) ResetEdge(name string) error {
	switch name {
	case deployment.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Deployment edge %s", name)
}

// LogicalDiskMutation represents an operation that mutates the LogicalDisk nodes in the graph.
type LogicalDiskMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	label                    *string
	filesystem               *string
	usage                    *int8
	addusage                 *int8
	size_in_units            *string
	remaining_space_in_units *string
	volume_name              *string
	bitlocker_status         *string
	clearedFields            map[string]struct{}
	owner                    *string
	clearedowner             bool
	done                     bool
	oldValue                 func(context.Context) (*LogicalDisk, error)
	predicates               []predicate.LogicalDisk
}

var _ ent.Mutation = (*LogicalDiskMutation)(nil)

// logicaldiskOption allows management of the mutation configuration using functional options.
type logicaldiskOption func(*LogicalDiskMutation)

// newLogicalDiskMutation creates new mutation for the LogicalDisk entity.
func newLogicalDiskMutation(c config, op Op, opts ...logicaldiskOption) *LogicalDiskMutation {
	m := &LogicalDiskMutation{
		config:        c,
		op:            op,
		typ:           TypeLogicalDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogicalDiskID sets the ID field of the mutation.
func withLogicalDiskID(id int) logicaldiskOption {
	return func(m *LogicalDiskMutation) {
		var (
			err   error
			once  sync.Once
			value *LogicalDisk
		)
		m.oldValue = func(ctx context.Context) (*LogicalDisk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogicalDisk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogicalDisk sets the old LogicalDisk of the mutation.
func withLogicalDisk(node *LogicalDisk) logicaldiskOption {
	return func(m *LogicalDiskMutation) {
		m.oldValue = func(context.Context) (*LogicalDisk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogicalDiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogicalDiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogicalDiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogicalDiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogicalDisk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *LogicalDiskMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *LogicalDiskMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *LogicalDiskMutation) ResetLabel() {
	m.label = nil
}

// SetFilesystem sets the "filesystem" field.
func (m *LogicalDiskMutation) SetFilesystem(s string) {
	m.filesystem = &s
}

// Filesystem returns the value of the "filesystem" field in the mutation.
func (m *LogicalDiskMutation) Filesystem() (r string, exists bool) {
	v := m.filesystem
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesystem returns the old "filesystem" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldFilesystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesystem: %w", err)
	}
	return oldValue.Filesystem, nil
}

// ClearFilesystem clears the value of the "filesystem" field.
func (m *LogicalDiskMutation) ClearFilesystem() {
	m.filesystem = nil
	m.clearedFields[logicaldisk.FieldFilesystem] = struct{}{}
}

// FilesystemCleared returns if the "filesystem" field was cleared in this mutation.
func (m *LogicalDiskMutation) FilesystemCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldFilesystem]
	return ok
}

// ResetFilesystem resets all changes to the "filesystem" field.
func (m *LogicalDiskMutation) ResetFilesystem() {
	m.filesystem = nil
	delete(m.clearedFields, logicaldisk.FieldFilesystem)
}

// SetUsage sets the "usage" field.
func (m *LogicalDiskMutation) SetUsage(i int8) {
	m.usage = &i
	m.addusage = nil
}

// Usage returns the value of the "usage" field in the mutation.
func (m *LogicalDiskMutation) Usage() (r int8, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldUsage(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// AddUsage adds i to the "usage" field.
func (m *LogicalDiskMutation) AddUsage(i int8) {
	if m.addusage != nil {
		*m.addusage += i
	} else {
		m.addusage = &i
	}
}

// AddedUsage returns the value that was added to the "usage" field in this mutation.
func (m *LogicalDiskMutation) AddedUsage() (r int8, exists bool) {
	v := m.addusage
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsage resets all changes to the "usage" field.
func (m *LogicalDiskMutation) ResetUsage() {
	m.usage = nil
	m.addusage = nil
}

// SetSizeInUnits sets the "size_in_units" field.
func (m *LogicalDiskMutation) SetSizeInUnits(s string) {
	m.size_in_units = &s
}

// SizeInUnits returns the value of the "size_in_units" field in the mutation.
func (m *LogicalDiskMutation) SizeInUnits() (r string, exists bool) {
	v := m.size_in_units
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInUnits returns the old "size_in_units" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldSizeInUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInUnits: %w", err)
	}
	return oldValue.SizeInUnits, nil
}

// ClearSizeInUnits clears the value of the "size_in_units" field.
func (m *LogicalDiskMutation) ClearSizeInUnits() {
	m.size_in_units = nil
	m.clearedFields[logicaldisk.FieldSizeInUnits] = struct{}{}
}

// SizeInUnitsCleared returns if the "size_in_units" field was cleared in this mutation.
func (m *LogicalDiskMutation) SizeInUnitsCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldSizeInUnits]
	return ok
}

// ResetSizeInUnits resets all changes to the "size_in_units" field.
func (m *LogicalDiskMutation) ResetSizeInUnits() {
	m.size_in_units = nil
	delete(m.clearedFields, logicaldisk.FieldSizeInUnits)
}

// SetRemainingSpaceInUnits sets the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) SetRemainingSpaceInUnits(s string) {
	m.remaining_space_in_units = &s
}

// RemainingSpaceInUnits returns the value of the "remaining_space_in_units" field in the mutation.
func (m *LogicalDiskMutation) RemainingSpaceInUnits() (r string, exists bool) {
	v := m.remaining_space_in_units
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingSpaceInUnits returns the old "remaining_space_in_units" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldRemainingSpaceInUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingSpaceInUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingSpaceInUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingSpaceInUnits: %w", err)
	}
	return oldValue.RemainingSpaceInUnits, nil
}

// ClearRemainingSpaceInUnits clears the value of the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) ClearRemainingSpaceInUnits() {
	m.remaining_space_in_units = nil
	m.clearedFields[logicaldisk.FieldRemainingSpaceInUnits] = struct{}{}
}

// RemainingSpaceInUnitsCleared returns if the "remaining_space_in_units" field was cleared in this mutation.
func (m *LogicalDiskMutation) RemainingSpaceInUnitsCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldRemainingSpaceInUnits]
	return ok
}

// ResetRemainingSpaceInUnits resets all changes to the "remaining_space_in_units" field.
func (m *LogicalDiskMutation) ResetRemainingSpaceInUnits() {
	m.remaining_space_in_units = nil
	delete(m.clearedFields, logicaldisk.FieldRemainingSpaceInUnits)
}

// SetVolumeName sets the "volume_name" field.
func (m *LogicalDiskMutation) SetVolumeName(s string) {
	m.volume_name = &s
}

// VolumeName returns the value of the "volume_name" field in the mutation.
func (m *LogicalDiskMutation) VolumeName() (r string, exists bool) {
	v := m.volume_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeName returns the old "volume_name" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldVolumeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeName: %w", err)
	}
	return oldValue.VolumeName, nil
}

// ClearVolumeName clears the value of the "volume_name" field.
func (m *LogicalDiskMutation) ClearVolumeName() {
	m.volume_name = nil
	m.clearedFields[logicaldisk.FieldVolumeName] = struct{}{}
}

// VolumeNameCleared returns if the "volume_name" field was cleared in this mutation.
func (m *LogicalDiskMutation) VolumeNameCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldVolumeName]
	return ok
}

// ResetVolumeName resets all changes to the "volume_name" field.
func (m *LogicalDiskMutation) ResetVolumeName() {
	m.volume_name = nil
	delete(m.clearedFields, logicaldisk.FieldVolumeName)
}

// SetBitlockerStatus sets the "bitlocker_status" field.
func (m *LogicalDiskMutation) SetBitlockerStatus(s string) {
	m.bitlocker_status = &s
}

// BitlockerStatus returns the value of the "bitlocker_status" field in the mutation.
func (m *LogicalDiskMutation) BitlockerStatus() (r string, exists bool) {
	v := m.bitlocker_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBitlockerStatus returns the old "bitlocker_status" field's value of the LogicalDisk entity.
// If the LogicalDisk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogicalDiskMutation) OldBitlockerStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBitlockerStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBitlockerStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBitlockerStatus: %w", err)
	}
	return oldValue.BitlockerStatus, nil
}

// ClearBitlockerStatus clears the value of the "bitlocker_status" field.
func (m *LogicalDiskMutation) ClearBitlockerStatus() {
	m.bitlocker_status = nil
	m.clearedFields[logicaldisk.FieldBitlockerStatus] = struct{}{}
}

// BitlockerStatusCleared returns if the "bitlocker_status" field was cleared in this mutation.
func (m *LogicalDiskMutation) BitlockerStatusCleared() bool {
	_, ok := m.clearedFields[logicaldisk.FieldBitlockerStatus]
	return ok
}

// ResetBitlockerStatus resets all changes to the "bitlocker_status" field.
func (m *LogicalDiskMutation) ResetBitlockerStatus() {
	m.bitlocker_status = nil
	delete(m.clearedFields, logicaldisk.FieldBitlockerStatus)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *LogicalDiskMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *LogicalDiskMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *LogicalDiskMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *LogicalDiskMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *LogicalDiskMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *LogicalDiskMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the LogicalDiskMutation builder.
func (m *LogicalDiskMutation) Where(ps ...predicate.LogicalDisk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogicalDiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogicalDiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LogicalDisk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogicalDiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogicalDiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LogicalDisk).
func (m *LogicalDiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogicalDiskMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.label != nil {
		fields = append(fields, logicaldisk.FieldLabel)
	}
	if m.filesystem != nil {
		fields = append(fields, logicaldisk.FieldFilesystem)
	}
	if m.usage != nil {
		fields = append(fields, logicaldisk.FieldUsage)
	}
	if m.size_in_units != nil {
		fields = append(fields, logicaldisk.FieldSizeInUnits)
	}
	if m.remaining_space_in_units != nil {
		fields = append(fields, logicaldisk.FieldRemainingSpaceInUnits)
	}
	if m.volume_name != nil {
		fields = append(fields, logicaldisk.FieldVolumeName)
	}
	if m.bitlocker_status != nil {
		fields = append(fields, logicaldisk.FieldBitlockerStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogicalDiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logicaldisk.FieldLabel:
		return m.Label()
	case logicaldisk.FieldFilesystem:
		return m.Filesystem()
	case logicaldisk.FieldUsage:
		return m.Usage()
	case logicaldisk.FieldSizeInUnits:
		return m.SizeInUnits()
	case logicaldisk.FieldRemainingSpaceInUnits:
		return m.RemainingSpaceInUnits()
	case logicaldisk.FieldVolumeName:
		return m.VolumeName()
	case logicaldisk.FieldBitlockerStatus:
		return m.BitlockerStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogicalDiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logicaldisk.FieldLabel:
		return m.OldLabel(ctx)
	case logicaldisk.FieldFilesystem:
		return m.OldFilesystem(ctx)
	case logicaldisk.FieldUsage:
		return m.OldUsage(ctx)
	case logicaldisk.FieldSizeInUnits:
		return m.OldSizeInUnits(ctx)
	case logicaldisk.FieldRemainingSpaceInUnits:
		return m.OldRemainingSpaceInUnits(ctx)
	case logicaldisk.FieldVolumeName:
		return m.OldVolumeName(ctx)
	case logicaldisk.FieldBitlockerStatus:
		return m.OldBitlockerStatus(ctx)
	}
	return nil, fmt.Errorf("unknown LogicalDisk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogicalDiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logicaldisk.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case logicaldisk.FieldFilesystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesystem(v)
		return nil
	case logicaldisk.FieldUsage:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case logicaldisk.FieldSizeInUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInUnits(v)
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingSpaceInUnits(v)
		return nil
	case logicaldisk.FieldVolumeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeName(v)
		return nil
	case logicaldisk.FieldBitlockerStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBitlockerStatus(v)
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogicalDiskMutation) AddedFields() []string {
	var fields []string
	if m.addusage != nil {
		fields = append(fields, logicaldisk.FieldUsage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogicalDiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logicaldisk.FieldUsage:
		return m.AddedUsage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogicalDiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logicaldisk.FieldUsage:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsage(v)
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogicalDiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logicaldisk.FieldFilesystem) {
		fields = append(fields, logicaldisk.FieldFilesystem)
	}
	if m.FieldCleared(logicaldisk.FieldSizeInUnits) {
		fields = append(fields, logicaldisk.FieldSizeInUnits)
	}
	if m.FieldCleared(logicaldisk.FieldRemainingSpaceInUnits) {
		fields = append(fields, logicaldisk.FieldRemainingSpaceInUnits)
	}
	if m.FieldCleared(logicaldisk.FieldVolumeName) {
		fields = append(fields, logicaldisk.FieldVolumeName)
	}
	if m.FieldCleared(logicaldisk.FieldBitlockerStatus) {
		fields = append(fields, logicaldisk.FieldBitlockerStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogicalDiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogicalDiskMutation) ClearField(name string) error {
	switch name {
	case logicaldisk.FieldFilesystem:
		m.ClearFilesystem()
		return nil
	case logicaldisk.FieldSizeInUnits:
		m.ClearSizeInUnits()
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		m.ClearRemainingSpaceInUnits()
		return nil
	case logicaldisk.FieldVolumeName:
		m.ClearVolumeName()
		return nil
	case logicaldisk.FieldBitlockerStatus:
		m.ClearBitlockerStatus()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogicalDiskMutation) ResetField(name string) error {
	switch name {
	case logicaldisk.FieldLabel:
		m.ResetLabel()
		return nil
	case logicaldisk.FieldFilesystem:
		m.ResetFilesystem()
		return nil
	case logicaldisk.FieldUsage:
		m.ResetUsage()
		return nil
	case logicaldisk.FieldSizeInUnits:
		m.ResetSizeInUnits()
		return nil
	case logicaldisk.FieldRemainingSpaceInUnits:
		m.ResetRemainingSpaceInUnits()
		return nil
	case logicaldisk.FieldVolumeName:
		m.ResetVolumeName()
		return nil
	case logicaldisk.FieldBitlockerStatus:
		m.ResetBitlockerStatus()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogicalDiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, logicaldisk.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogicalDiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logicaldisk.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogicalDiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogicalDiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogicalDiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, logicaldisk.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogicalDiskMutation) EdgeCleared(name string) bool {
	switch name {
	case logicaldisk.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogicalDiskMutation) ClearEdge(name string) error {
	switch name {
	case logicaldisk.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogicalDiskMutation) ResetEdge(name string) error {
	switch name {
	case logicaldisk.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown LogicalDisk edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	value         *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	org           *int
	clearedorg    bool
	done          bool
	oldValue      func(context.Context) (*Metadata, error)
	predicates    []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id int) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Metadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *MetadataMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *MetadataMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *MetadataMutation) ResetValue() {
	m.value = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *MetadataMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *MetadataMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *MetadataMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MetadataMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MetadataMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetOrgID sets the "org" edge to the OrgMetadata entity by id.
func (m *MetadataMutation) SetOrgID(id int) {
	m.org = &id
}

// ClearOrg clears the "org" edge to the OrgMetadata entity.
func (m *MetadataMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the OrgMetadata entity was cleared.
func (m *MetadataMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgID returns the "org" edge ID in the mutation.
func (m *MetadataMutation) OrgID() (id int, exists bool) {
	if m.org != nil {
		return *m.org, true
	}
	return
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *MetadataMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Metadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, metadata.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, metadata.EdgeOwner)
	}
	if m.org != nil {
		edges = append(edges, metadata.EdgeOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case metadata.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, metadata.EdgeOwner)
	}
	if m.clearedorg {
		edges = append(edges, metadata.EdgeOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeOwner:
		return m.clearedowner
	case metadata.EdgeOrg:
		return m.clearedorg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeOwner:
		m.ClearOwner()
		return nil
	case metadata.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeOwner:
		m.ResetOwner()
		return nil
	case metadata.EdgeOrg:
		m.ResetOrg()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// MonitorMutation represents an operation that mutates the Monitor nodes in the graph.
type MonitorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	manufacturer  *string
	model         *string
	serial        *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Monitor, error)
	predicates    []predicate.Monitor
}

var _ ent.Mutation = (*MonitorMutation)(nil)

// monitorOption allows management of the mutation configuration using functional options.
type monitorOption func(*MonitorMutation)

// newMonitorMutation creates new mutation for the Monitor entity.
func newMonitorMutation(c config, op Op, opts ...monitorOption) *MonitorMutation {
	m := &MonitorMutation{
		config:        c,
		op:            op,
		typ:           TypeMonitor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMonitorID sets the ID field of the mutation.
func withMonitorID(id int) monitorOption {
	return func(m *MonitorMutation) {
		var (
			err   error
			once  sync.Once
			value *Monitor
		)
		m.oldValue = func(ctx context.Context) (*Monitor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Monitor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMonitor sets the old Monitor of the mutation.
func withMonitor(node *Monitor) monitorOption {
	return func(m *MonitorMutation) {
		m.oldValue = func(context.Context) (*Monitor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MonitorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MonitorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MonitorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MonitorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Monitor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManufacturer sets the "manufacturer" field.
func (m *MonitorMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *MonitorMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ClearManufacturer clears the value of the "manufacturer" field.
func (m *MonitorMutation) ClearManufacturer() {
	m.manufacturer = nil
	m.clearedFields[monitor.FieldManufacturer] = struct{}{}
}

// ManufacturerCleared returns if the "manufacturer" field was cleared in this mutation.
func (m *MonitorMutation) ManufacturerCleared() bool {
	_, ok := m.clearedFields[monitor.FieldManufacturer]
	return ok
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *MonitorMutation) ResetManufacturer() {
	m.manufacturer = nil
	delete(m.clearedFields, monitor.FieldManufacturer)
}

// SetModel sets the "model" field.
func (m *MonitorMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *MonitorMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *MonitorMutation) ClearModel() {
	m.model = nil
	m.clearedFields[monitor.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *MonitorMutation) ModelCleared() bool {
	_, ok := m.clearedFields[monitor.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *MonitorMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, monitor.FieldModel)
}

// SetSerial sets the "serial" field.
func (m *MonitorMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *MonitorMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Monitor entity.
// If the Monitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MonitorMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *MonitorMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[monitor.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *MonitorMutation) SerialCleared() bool {
	_, ok := m.clearedFields[monitor.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *MonitorMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, monitor.FieldSerial)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *MonitorMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *MonitorMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *MonitorMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MonitorMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MonitorMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MonitorMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MonitorMutation builder.
func (m *MonitorMutation) Where(ps ...predicate.Monitor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MonitorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MonitorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Monitor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MonitorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MonitorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Monitor).
func (m *MonitorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MonitorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.manufacturer != nil {
		fields = append(fields, monitor.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, monitor.FieldModel)
	}
	if m.serial != nil {
		fields = append(fields, monitor.FieldSerial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MonitorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case monitor.FieldManufacturer:
		return m.Manufacturer()
	case monitor.FieldModel:
		return m.Model()
	case monitor.FieldSerial:
		return m.Serial()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MonitorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case monitor.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case monitor.FieldModel:
		return m.OldModel(ctx)
	case monitor.FieldSerial:
		return m.OldSerial(ctx)
	}
	return nil, fmt.Errorf("unknown Monitor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonitorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case monitor.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case monitor.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case monitor.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	}
	return fmt.Errorf("unknown Monitor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MonitorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MonitorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MonitorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Monitor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MonitorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(monitor.FieldManufacturer) {
		fields = append(fields, monitor.FieldManufacturer)
	}
	if m.FieldCleared(monitor.FieldModel) {
		fields = append(fields, monitor.FieldModel)
	}
	if m.FieldCleared(monitor.FieldSerial) {
		fields = append(fields, monitor.FieldSerial)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MonitorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MonitorMutation) ClearField(name string) error {
	switch name {
	case monitor.FieldManufacturer:
		m.ClearManufacturer()
		return nil
	case monitor.FieldModel:
		m.ClearModel()
		return nil
	case monitor.FieldSerial:
		m.ClearSerial()
		return nil
	}
	return fmt.Errorf("unknown Monitor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MonitorMutation) ResetField(name string) error {
	switch name {
	case monitor.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case monitor.FieldModel:
		m.ResetModel()
		return nil
	case monitor.FieldSerial:
		m.ResetSerial()
		return nil
	}
	return fmt.Errorf("unknown Monitor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MonitorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, monitor.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MonitorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case monitor.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MonitorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MonitorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MonitorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, monitor.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MonitorMutation) EdgeCleared(name string) bool {
	switch name {
	case monitor.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MonitorMutation) ClearEdge(name string) error {
	switch name {
	case monitor.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Monitor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MonitorMutation) ResetEdge(name string) error {
	switch name {
	case monitor.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Monitor edge %s", name)
}

// NetworkAdapterMutation represents an operation that mutates the NetworkAdapter nodes in the graph.
type NetworkAdapterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	mac_address         *string
	addresses           *string
	subnet              *string
	default_gateway     *string
	dns_servers         *string
	dns_domain          *string
	dhcp_enabled        *bool
	dhcp_lease_obtained *time.Time
	dhcp_lease_expired  *time.Time
	speed               *string
	clearedFields       map[string]struct{}
	owner               *string
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*NetworkAdapter, error)
	predicates          []predicate.NetworkAdapter
}

var _ ent.Mutation = (*NetworkAdapterMutation)(nil)

// networkadapterOption allows management of the mutation configuration using functional options.
type networkadapterOption func(*NetworkAdapterMutation)

// newNetworkAdapterMutation creates new mutation for the NetworkAdapter entity.
func newNetworkAdapterMutation(c config, op Op, opts ...networkadapterOption) *NetworkAdapterMutation {
	m := &NetworkAdapterMutation{
		config:        c,
		op:            op,
		typ:           TypeNetworkAdapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkAdapterID sets the ID field of the mutation.
func withNetworkAdapterID(id int) networkadapterOption {
	return func(m *NetworkAdapterMutation) {
		var (
			err   error
			once  sync.Once
			value *NetworkAdapter
		)
		m.oldValue = func(ctx context.Context) (*NetworkAdapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NetworkAdapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetworkAdapter sets the old NetworkAdapter of the mutation.
func withNetworkAdapter(node *NetworkAdapter) networkadapterOption {
	return func(m *NetworkAdapterMutation) {
		m.oldValue = func(context.Context) (*NetworkAdapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkAdapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkAdapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkAdapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkAdapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NetworkAdapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NetworkAdapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkAdapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkAdapterMutation) ResetName() {
	m.name = nil
}

// SetMACAddress sets the "mac_address" field.
func (m *NetworkAdapterMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *NetworkAdapterMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *NetworkAdapterMutation) ResetMACAddress() {
	m.mac_address = nil
}

// SetAddresses sets the "addresses" field.
func (m *NetworkAdapterMutation) SetAddresses(s string) {
	m.addresses = &s
}

// Addresses returns the value of the "addresses" field in the mutation.
func (m *NetworkAdapterMutation) Addresses() (r string, exists bool) {
	v := m.addresses
	if v == nil {
		return
	}
	return *v, true
}

// OldAddresses returns the old "addresses" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldAddresses(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddresses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddresses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddresses: %w", err)
	}
	return oldValue.Addresses, nil
}

// ResetAddresses resets all changes to the "addresses" field.
func (m *NetworkAdapterMutation) ResetAddresses() {
	m.addresses = nil
}

// SetSubnet sets the "subnet" field.
func (m *NetworkAdapterMutation) SetSubnet(s string) {
	m.subnet = &s
}

// Subnet returns the value of the "subnet" field in the mutation.
func (m *NetworkAdapterMutation) Subnet() (r string, exists bool) {
	v := m.subnet
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnet returns the old "subnet" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldSubnet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnet: %w", err)
	}
	return oldValue.Subnet, nil
}

// ClearSubnet clears the value of the "subnet" field.
func (m *NetworkAdapterMutation) ClearSubnet() {
	m.subnet = nil
	m.clearedFields[networkadapter.FieldSubnet] = struct{}{}
}

// SubnetCleared returns if the "subnet" field was cleared in this mutation.
func (m *NetworkAdapterMutation) SubnetCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldSubnet]
	return ok
}

// ResetSubnet resets all changes to the "subnet" field.
func (m *NetworkAdapterMutation) ResetSubnet() {
	m.subnet = nil
	delete(m.clearedFields, networkadapter.FieldSubnet)
}

// SetDefaultGateway sets the "default_gateway" field.
func (m *NetworkAdapterMutation) SetDefaultGateway(s string) {
	m.default_gateway = &s
}

// DefaultGateway returns the value of the "default_gateway" field in the mutation.
func (m *NetworkAdapterMutation) DefaultGateway() (r string, exists bool) {
	v := m.default_gateway
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultGateway returns the old "default_gateway" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDefaultGateway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultGateway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultGateway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultGateway: %w", err)
	}
	return oldValue.DefaultGateway, nil
}

// ClearDefaultGateway clears the value of the "default_gateway" field.
func (m *NetworkAdapterMutation) ClearDefaultGateway() {
	m.default_gateway = nil
	m.clearedFields[networkadapter.FieldDefaultGateway] = struct{}{}
}

// DefaultGatewayCleared returns if the "default_gateway" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DefaultGatewayCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDefaultGateway]
	return ok
}

// ResetDefaultGateway resets all changes to the "default_gateway" field.
func (m *NetworkAdapterMutation) ResetDefaultGateway() {
	m.default_gateway = nil
	delete(m.clearedFields, networkadapter.FieldDefaultGateway)
}

// SetDNSServers sets the "dns_servers" field.
func (m *NetworkAdapterMutation) SetDNSServers(s string) {
	m.dns_servers = &s
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *NetworkAdapterMutation) DNSServers() (r string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDNSServers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ClearDNSServers clears the value of the "dns_servers" field.
func (m *NetworkAdapterMutation) ClearDNSServers() {
	m.dns_servers = nil
	m.clearedFields[networkadapter.FieldDNSServers] = struct{}{}
}

// DNSServersCleared returns if the "dns_servers" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DNSServersCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDNSServers]
	return ok
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *NetworkAdapterMutation) ResetDNSServers() {
	m.dns_servers = nil
	delete(m.clearedFields, networkadapter.FieldDNSServers)
}

// SetDNSDomain sets the "dns_domain" field.
func (m *NetworkAdapterMutation) SetDNSDomain(s string) {
	m.dns_domain = &s
}

// DNSDomain returns the value of the "dns_domain" field in the mutation.
func (m *NetworkAdapterMutation) DNSDomain() (r string, exists bool) {
	v := m.dns_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSDomain returns the old "dns_domain" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDNSDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSDomain: %w", err)
	}
	return oldValue.DNSDomain, nil
}

// ClearDNSDomain clears the value of the "dns_domain" field.
func (m *NetworkAdapterMutation) ClearDNSDomain() {
	m.dns_domain = nil
	m.clearedFields[networkadapter.FieldDNSDomain] = struct{}{}
}

// DNSDomainCleared returns if the "dns_domain" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DNSDomainCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDNSDomain]
	return ok
}

// ResetDNSDomain resets all changes to the "dns_domain" field.
func (m *NetworkAdapterMutation) ResetDNSDomain() {
	m.dns_domain = nil
	delete(m.clearedFields, networkadapter.FieldDNSDomain)
}

// SetDhcpEnabled sets the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) SetDhcpEnabled(b bool) {
	m.dhcp_enabled = &b
}

// DhcpEnabled returns the value of the "dhcp_enabled" field in the mutation.
func (m *NetworkAdapterMutation) DhcpEnabled() (r bool, exists bool) {
	v := m.dhcp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpEnabled returns the old "dhcp_enabled" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpEnabled: %w", err)
	}
	return oldValue.DhcpEnabled, nil
}

// ClearDhcpEnabled clears the value of the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) ClearDhcpEnabled() {
	m.dhcp_enabled = nil
	m.clearedFields[networkadapter.FieldDhcpEnabled] = struct{}{}
}

// DhcpEnabledCleared returns if the "dhcp_enabled" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpEnabledCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpEnabled]
	return ok
}

// ResetDhcpEnabled resets all changes to the "dhcp_enabled" field.
func (m *NetworkAdapterMutation) ResetDhcpEnabled() {
	m.dhcp_enabled = nil
	delete(m.clearedFields, networkadapter.FieldDhcpEnabled)
}

// SetDhcpLeaseObtained sets the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) SetDhcpLeaseObtained(t time.Time) {
	m.dhcp_lease_obtained = &t
}

// DhcpLeaseObtained returns the value of the "dhcp_lease_obtained" field in the mutation.
func (m *NetworkAdapterMutation) DhcpLeaseObtained() (r time.Time, exists bool) {
	v := m.dhcp_lease_obtained
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpLeaseObtained returns the old "dhcp_lease_obtained" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpLeaseObtained(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpLeaseObtained is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpLeaseObtained requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpLeaseObtained: %w", err)
	}
	return oldValue.DhcpLeaseObtained, nil
}

// ClearDhcpLeaseObtained clears the value of the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) ClearDhcpLeaseObtained() {
	m.dhcp_lease_obtained = nil
	m.clearedFields[networkadapter.FieldDhcpLeaseObtained] = struct{}{}
}

// DhcpLeaseObtainedCleared returns if the "dhcp_lease_obtained" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpLeaseObtainedCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpLeaseObtained]
	return ok
}

// ResetDhcpLeaseObtained resets all changes to the "dhcp_lease_obtained" field.
func (m *NetworkAdapterMutation) ResetDhcpLeaseObtained() {
	m.dhcp_lease_obtained = nil
	delete(m.clearedFields, networkadapter.FieldDhcpLeaseObtained)
}

// SetDhcpLeaseExpired sets the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) SetDhcpLeaseExpired(t time.Time) {
	m.dhcp_lease_expired = &t
}

// DhcpLeaseExpired returns the value of the "dhcp_lease_expired" field in the mutation.
func (m *NetworkAdapterMutation) DhcpLeaseExpired() (r time.Time, exists bool) {
	v := m.dhcp_lease_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldDhcpLeaseExpired returns the old "dhcp_lease_expired" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldDhcpLeaseExpired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDhcpLeaseExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDhcpLeaseExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDhcpLeaseExpired: %w", err)
	}
	return oldValue.DhcpLeaseExpired, nil
}

// ClearDhcpLeaseExpired clears the value of the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) ClearDhcpLeaseExpired() {
	m.dhcp_lease_expired = nil
	m.clearedFields[networkadapter.FieldDhcpLeaseExpired] = struct{}{}
}

// DhcpLeaseExpiredCleared returns if the "dhcp_lease_expired" field was cleared in this mutation.
func (m *NetworkAdapterMutation) DhcpLeaseExpiredCleared() bool {
	_, ok := m.clearedFields[networkadapter.FieldDhcpLeaseExpired]
	return ok
}

// ResetDhcpLeaseExpired resets all changes to the "dhcp_lease_expired" field.
func (m *NetworkAdapterMutation) ResetDhcpLeaseExpired() {
	m.dhcp_lease_expired = nil
	delete(m.clearedFields, networkadapter.FieldDhcpLeaseExpired)
}

// SetSpeed sets the "speed" field.
func (m *NetworkAdapterMutation) SetSpeed(s string) {
	m.speed = &s
}

// Speed returns the value of the "speed" field in the mutation.
func (m *NetworkAdapterMutation) Speed() (r string, exists bool) {
	v := m.speed
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeed returns the old "speed" field's value of the NetworkAdapter entity.
// If the NetworkAdapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkAdapterMutation) OldSpeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeed: %w", err)
	}
	return oldValue.Speed, nil
}

// ResetSpeed resets all changes to the "speed" field.
func (m *NetworkAdapterMutation) ResetSpeed() {
	m.speed = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *NetworkAdapterMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *NetworkAdapterMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *NetworkAdapterMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NetworkAdapterMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NetworkAdapterMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NetworkAdapterMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NetworkAdapterMutation builder.
func (m *NetworkAdapterMutation) Where(ps ...predicate.NetworkAdapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkAdapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkAdapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NetworkAdapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkAdapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkAdapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NetworkAdapter).
func (m *NetworkAdapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkAdapterMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, networkadapter.FieldName)
	}
	if m.mac_address != nil {
		fields = append(fields, networkadapter.FieldMACAddress)
	}
	if m.addresses != nil {
		fields = append(fields, networkadapter.FieldAddresses)
	}
	if m.subnet != nil {
		fields = append(fields, networkadapter.FieldSubnet)
	}
	if m.default_gateway != nil {
		fields = append(fields, networkadapter.FieldDefaultGateway)
	}
	if m.dns_servers != nil {
		fields = append(fields, networkadapter.FieldDNSServers)
	}
	if m.dns_domain != nil {
		fields = append(fields, networkadapter.FieldDNSDomain)
	}
	if m.dhcp_enabled != nil {
		fields = append(fields, networkadapter.FieldDhcpEnabled)
	}
	if m.dhcp_lease_obtained != nil {
		fields = append(fields, networkadapter.FieldDhcpLeaseObtained)
	}
	if m.dhcp_lease_expired != nil {
		fields = append(fields, networkadapter.FieldDhcpLeaseExpired)
	}
	if m.speed != nil {
		fields = append(fields, networkadapter.FieldSpeed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkAdapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case networkadapter.FieldName:
		return m.Name()
	case networkadapter.FieldMACAddress:
		return m.MACAddress()
	case networkadapter.FieldAddresses:
		return m.Addresses()
	case networkadapter.FieldSubnet:
		return m.Subnet()
	case networkadapter.FieldDefaultGateway:
		return m.DefaultGateway()
	case networkadapter.FieldDNSServers:
		return m.DNSServers()
	case networkadapter.FieldDNSDomain:
		return m.DNSDomain()
	case networkadapter.FieldDhcpEnabled:
		return m.DhcpEnabled()
	case networkadapter.FieldDhcpLeaseObtained:
		return m.DhcpLeaseObtained()
	case networkadapter.FieldDhcpLeaseExpired:
		return m.DhcpLeaseExpired()
	case networkadapter.FieldSpeed:
		return m.Speed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkAdapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case networkadapter.FieldName:
		return m.OldName(ctx)
	case networkadapter.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case networkadapter.FieldAddresses:
		return m.OldAddresses(ctx)
	case networkadapter.FieldSubnet:
		return m.OldSubnet(ctx)
	case networkadapter.FieldDefaultGateway:
		return m.OldDefaultGateway(ctx)
	case networkadapter.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case networkadapter.FieldDNSDomain:
		return m.OldDNSDomain(ctx)
	case networkadapter.FieldDhcpEnabled:
		return m.OldDhcpEnabled(ctx)
	case networkadapter.FieldDhcpLeaseObtained:
		return m.OldDhcpLeaseObtained(ctx)
	case networkadapter.FieldDhcpLeaseExpired:
		return m.OldDhcpLeaseExpired(ctx)
	case networkadapter.FieldSpeed:
		return m.OldSpeed(ctx)
	}
	return nil, fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkAdapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case networkadapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case networkadapter.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case networkadapter.FieldAddresses:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddresses(v)
		return nil
	case networkadapter.FieldSubnet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnet(v)
		return nil
	case networkadapter.FieldDefaultGateway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultGateway(v)
		return nil
	case networkadapter.FieldDNSServers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case networkadapter.FieldDNSDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSDomain(v)
		return nil
	case networkadapter.FieldDhcpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpEnabled(v)
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpLeaseObtained(v)
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDhcpLeaseExpired(v)
		return nil
	case networkadapter.FieldSpeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeed(v)
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkAdapterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkAdapterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkAdapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NetworkAdapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkAdapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(networkadapter.FieldSubnet) {
		fields = append(fields, networkadapter.FieldSubnet)
	}
	if m.FieldCleared(networkadapter.FieldDefaultGateway) {
		fields = append(fields, networkadapter.FieldDefaultGateway)
	}
	if m.FieldCleared(networkadapter.FieldDNSServers) {
		fields = append(fields, networkadapter.FieldDNSServers)
	}
	if m.FieldCleared(networkadapter.FieldDNSDomain) {
		fields = append(fields, networkadapter.FieldDNSDomain)
	}
	if m.FieldCleared(networkadapter.FieldDhcpEnabled) {
		fields = append(fields, networkadapter.FieldDhcpEnabled)
	}
	if m.FieldCleared(networkadapter.FieldDhcpLeaseObtained) {
		fields = append(fields, networkadapter.FieldDhcpLeaseObtained)
	}
	if m.FieldCleared(networkadapter.FieldDhcpLeaseExpired) {
		fields = append(fields, networkadapter.FieldDhcpLeaseExpired)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkAdapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkAdapterMutation) ClearField(name string) error {
	switch name {
	case networkadapter.FieldSubnet:
		m.ClearSubnet()
		return nil
	case networkadapter.FieldDefaultGateway:
		m.ClearDefaultGateway()
		return nil
	case networkadapter.FieldDNSServers:
		m.ClearDNSServers()
		return nil
	case networkadapter.FieldDNSDomain:
		m.ClearDNSDomain()
		return nil
	case networkadapter.FieldDhcpEnabled:
		m.ClearDhcpEnabled()
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		m.ClearDhcpLeaseObtained()
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		m.ClearDhcpLeaseExpired()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkAdapterMutation) ResetField(name string) error {
	switch name {
	case networkadapter.FieldName:
		m.ResetName()
		return nil
	case networkadapter.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case networkadapter.FieldAddresses:
		m.ResetAddresses()
		return nil
	case networkadapter.FieldSubnet:
		m.ResetSubnet()
		return nil
	case networkadapter.FieldDefaultGateway:
		m.ResetDefaultGateway()
		return nil
	case networkadapter.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case networkadapter.FieldDNSDomain:
		m.ResetDNSDomain()
		return nil
	case networkadapter.FieldDhcpEnabled:
		m.ResetDhcpEnabled()
		return nil
	case networkadapter.FieldDhcpLeaseObtained:
		m.ResetDhcpLeaseObtained()
		return nil
	case networkadapter.FieldDhcpLeaseExpired:
		m.ResetDhcpLeaseExpired()
		return nil
	case networkadapter.FieldSpeed:
		m.ResetSpeed()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkAdapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, networkadapter.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkAdapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case networkadapter.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkAdapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkAdapterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkAdapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, networkadapter.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkAdapterMutation) EdgeCleared(name string) bool {
	switch name {
	case networkadapter.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkAdapterMutation) ClearEdge(name string) error {
	switch name {
	case networkadapter.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkAdapterMutation) ResetEdge(name string) error {
	switch name {
	case networkadapter.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown NetworkAdapter edge %s", name)
}

// OperatingSystemMutation represents an operation that mutates the OperatingSystem nodes in the graph.
type OperatingSystemMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_type            *string
	version          *string
	description      *string
	edition          *string
	install_date     *time.Time
	arch             *string
	username         *string
	last_bootup_time *time.Time
	clearedFields    map[string]struct{}
	owner            *string
	clearedowner     bool
	done             bool
	oldValue         func(context.Context) (*OperatingSystem, error)
	predicates       []predicate.OperatingSystem
}

var _ ent.Mutation = (*OperatingSystemMutation)(nil)

// operatingsystemOption allows management of the mutation configuration using functional options.
type operatingsystemOption func(*OperatingSystemMutation)

// newOperatingSystemMutation creates new mutation for the OperatingSystem entity.
func newOperatingSystemMutation(c config, op Op, opts ...operatingsystemOption) *OperatingSystemMutation {
	m := &OperatingSystemMutation{
		config:        c,
		op:            op,
		typ:           TypeOperatingSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperatingSystemID sets the ID field of the mutation.
func withOperatingSystemID(id int) operatingsystemOption {
	return func(m *OperatingSystemMutation) {
		var (
			err   error
			once  sync.Once
			value *OperatingSystem
		)
		m.oldValue = func(ctx context.Context) (*OperatingSystem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OperatingSystem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperatingSystem sets the old OperatingSystem of the mutation.
func withOperatingSystem(node *OperatingSystem) operatingsystemOption {
	return func(m *OperatingSystemMutation) {
		m.oldValue = func(context.Context) (*OperatingSystem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperatingSystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperatingSystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperatingSystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperatingSystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OperatingSystem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *OperatingSystemMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *OperatingSystemMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *OperatingSystemMutation) ClearType() {
	m._type = nil
	m.clearedFields[operatingsystem.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *OperatingSystemMutation) TypeCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *OperatingSystemMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, operatingsystem.FieldType)
}

// SetVersion sets the "version" field.
func (m *OperatingSystemMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *OperatingSystemMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *OperatingSystemMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *OperatingSystemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OperatingSystemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OperatingSystemMutation) ResetDescription() {
	m.description = nil
}

// SetEdition sets the "edition" field.
func (m *OperatingSystemMutation) SetEdition(s string) {
	m.edition = &s
}

// Edition returns the value of the "edition" field in the mutation.
func (m *OperatingSystemMutation) Edition() (r string, exists bool) {
	v := m.edition
	if v == nil {
		return
	}
	return *v, true
}

// OldEdition returns the old "edition" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldEdition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEdition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEdition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEdition: %w", err)
	}
	return oldValue.Edition, nil
}

// ClearEdition clears the value of the "edition" field.
func (m *OperatingSystemMutation) ClearEdition() {
	m.edition = nil
	m.clearedFields[operatingsystem.FieldEdition] = struct{}{}
}

// EditionCleared returns if the "edition" field was cleared in this mutation.
func (m *OperatingSystemMutation) EditionCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldEdition]
	return ok
}

// ResetEdition resets all changes to the "edition" field.
func (m *OperatingSystemMutation) ResetEdition() {
	m.edition = nil
	delete(m.clearedFields, operatingsystem.FieldEdition)
}

// SetInstallDate sets the "install_date" field.
func (m *OperatingSystemMutation) SetInstallDate(t time.Time) {
	m.install_date = &t
}

// InstallDate returns the value of the "install_date" field in the mutation.
func (m *OperatingSystemMutation) InstallDate() (r time.Time, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old "install_date" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldInstallDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of the "install_date" field.
func (m *OperatingSystemMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[operatingsystem.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the "install_date" field was cleared in this mutation.
func (m *OperatingSystemMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldInstallDate]
	return ok
}

// ResetInstallDate resets all changes to the "install_date" field.
func (m *OperatingSystemMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, operatingsystem.FieldInstallDate)
}

// SetArch sets the "arch" field.
func (m *OperatingSystemMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *OperatingSystemMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ClearArch clears the value of the "arch" field.
func (m *OperatingSystemMutation) ClearArch() {
	m.arch = nil
	m.clearedFields[operatingsystem.FieldArch] = struct{}{}
}

// ArchCleared returns if the "arch" field was cleared in this mutation.
func (m *OperatingSystemMutation) ArchCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldArch]
	return ok
}

// ResetArch resets all changes to the "arch" field.
func (m *OperatingSystemMutation) ResetArch() {
	m.arch = nil
	delete(m.clearedFields, operatingsystem.FieldArch)
}

// SetUsername sets the "username" field.
func (m *OperatingSystemMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperatingSystemMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *OperatingSystemMutation) ResetUsername() {
	m.username = nil
}

// SetLastBootupTime sets the "last_bootup_time" field.
func (m *OperatingSystemMutation) SetLastBootupTime(t time.Time) {
	m.last_bootup_time = &t
}

// LastBootupTime returns the value of the "last_bootup_time" field in the mutation.
func (m *OperatingSystemMutation) LastBootupTime() (r time.Time, exists bool) {
	v := m.last_bootup_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBootupTime returns the old "last_bootup_time" field's value of the OperatingSystem entity.
// If the OperatingSystem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperatingSystemMutation) OldLastBootupTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBootupTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBootupTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBootupTime: %w", err)
	}
	return oldValue.LastBootupTime, nil
}

// ClearLastBootupTime clears the value of the "last_bootup_time" field.
func (m *OperatingSystemMutation) ClearLastBootupTime() {
	m.last_bootup_time = nil
	m.clearedFields[operatingsystem.FieldLastBootupTime] = struct{}{}
}

// LastBootupTimeCleared returns if the "last_bootup_time" field was cleared in this mutation.
func (m *OperatingSystemMutation) LastBootupTimeCleared() bool {
	_, ok := m.clearedFields[operatingsystem.FieldLastBootupTime]
	return ok
}

// ResetLastBootupTime resets all changes to the "last_bootup_time" field.
func (m *OperatingSystemMutation) ResetLastBootupTime() {
	m.last_bootup_time = nil
	delete(m.clearedFields, operatingsystem.FieldLastBootupTime)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *OperatingSystemMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *OperatingSystemMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *OperatingSystemMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *OperatingSystemMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OperatingSystemMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OperatingSystemMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the OperatingSystemMutation builder.
func (m *OperatingSystemMutation) Where(ps ...predicate.OperatingSystem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperatingSystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperatingSystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OperatingSystem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperatingSystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperatingSystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OperatingSystem).
func (m *OperatingSystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperatingSystemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._type != nil {
		fields = append(fields, operatingsystem.FieldType)
	}
	if m.version != nil {
		fields = append(fields, operatingsystem.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, operatingsystem.FieldDescription)
	}
	if m.edition != nil {
		fields = append(fields, operatingsystem.FieldEdition)
	}
	if m.install_date != nil {
		fields = append(fields, operatingsystem.FieldInstallDate)
	}
	if m.arch != nil {
		fields = append(fields, operatingsystem.FieldArch)
	}
	if m.username != nil {
		fields = append(fields, operatingsystem.FieldUsername)
	}
	if m.last_bootup_time != nil {
		fields = append(fields, operatingsystem.FieldLastBootupTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperatingSystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operatingsystem.FieldType:
		return m.GetType()
	case operatingsystem.FieldVersion:
		return m.Version()
	case operatingsystem.FieldDescription:
		return m.Description()
	case operatingsystem.FieldEdition:
		return m.Edition()
	case operatingsystem.FieldInstallDate:
		return m.InstallDate()
	case operatingsystem.FieldArch:
		return m.Arch()
	case operatingsystem.FieldUsername:
		return m.Username()
	case operatingsystem.FieldLastBootupTime:
		return m.LastBootupTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperatingSystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operatingsystem.FieldType:
		return m.OldType(ctx)
	case operatingsystem.FieldVersion:
		return m.OldVersion(ctx)
	case operatingsystem.FieldDescription:
		return m.OldDescription(ctx)
	case operatingsystem.FieldEdition:
		return m.OldEdition(ctx)
	case operatingsystem.FieldInstallDate:
		return m.OldInstallDate(ctx)
	case operatingsystem.FieldArch:
		return m.OldArch(ctx)
	case operatingsystem.FieldUsername:
		return m.OldUsername(ctx)
	case operatingsystem.FieldLastBootupTime:
		return m.OldLastBootupTime(ctx)
	}
	return nil, fmt.Errorf("unknown OperatingSystem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatingSystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operatingsystem.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case operatingsystem.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case operatingsystem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case operatingsystem.FieldEdition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEdition(v)
		return nil
	case operatingsystem.FieldInstallDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	case operatingsystem.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	case operatingsystem.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operatingsystem.FieldLastBootupTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBootupTime(v)
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperatingSystemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperatingSystemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperatingSystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OperatingSystem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperatingSystemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operatingsystem.FieldType) {
		fields = append(fields, operatingsystem.FieldType)
	}
	if m.FieldCleared(operatingsystem.FieldEdition) {
		fields = append(fields, operatingsystem.FieldEdition)
	}
	if m.FieldCleared(operatingsystem.FieldInstallDate) {
		fields = append(fields, operatingsystem.FieldInstallDate)
	}
	if m.FieldCleared(operatingsystem.FieldArch) {
		fields = append(fields, operatingsystem.FieldArch)
	}
	if m.FieldCleared(operatingsystem.FieldLastBootupTime) {
		fields = append(fields, operatingsystem.FieldLastBootupTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperatingSystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperatingSystemMutation) ClearField(name string) error {
	switch name {
	case operatingsystem.FieldType:
		m.ClearType()
		return nil
	case operatingsystem.FieldEdition:
		m.ClearEdition()
		return nil
	case operatingsystem.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	case operatingsystem.FieldArch:
		m.ClearArch()
		return nil
	case operatingsystem.FieldLastBootupTime:
		m.ClearLastBootupTime()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperatingSystemMutation) ResetField(name string) error {
	switch name {
	case operatingsystem.FieldType:
		m.ResetType()
		return nil
	case operatingsystem.FieldVersion:
		m.ResetVersion()
		return nil
	case operatingsystem.FieldDescription:
		m.ResetDescription()
		return nil
	case operatingsystem.FieldEdition:
		m.ResetEdition()
		return nil
	case operatingsystem.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	case operatingsystem.FieldArch:
		m.ResetArch()
		return nil
	case operatingsystem.FieldUsername:
		m.ResetUsername()
		return nil
	case operatingsystem.FieldLastBootupTime:
		m.ResetLastBootupTime()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperatingSystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, operatingsystem.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperatingSystemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operatingsystem.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperatingSystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperatingSystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperatingSystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, operatingsystem.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperatingSystemMutation) EdgeCleared(name string) bool {
	switch name {
	case operatingsystem.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperatingSystemMutation) ClearEdge(name string) error {
	switch name {
	case operatingsystem.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperatingSystemMutation) ResetEdge(name string) error {
	switch name {
	case operatingsystem.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown OperatingSystem edge %s", name)
}

// OrgMetadataMutation represents an operation that mutates the OrgMetadata nodes in the graph.
type OrgMetadataMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	description     *string
	clearedFields   map[string]struct{}
	metadata        map[int]struct{}
	removedmetadata map[int]struct{}
	clearedmetadata bool
	done            bool
	oldValue        func(context.Context) (*OrgMetadata, error)
	predicates      []predicate.OrgMetadata
}

var _ ent.Mutation = (*OrgMetadataMutation)(nil)

// orgmetadataOption allows management of the mutation configuration using functional options.
type orgmetadataOption func(*OrgMetadataMutation)

// newOrgMetadataMutation creates new mutation for the OrgMetadata entity.
func newOrgMetadataMutation(c config, op Op, opts ...orgmetadataOption) *OrgMetadataMutation {
	m := &OrgMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgMetadataID sets the ID field of the mutation.
func withOrgMetadataID(id int) orgmetadataOption {
	return func(m *OrgMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgMetadata
		)
		m.oldValue = func(ctx context.Context) (*OrgMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgMetadata sets the old OrgMetadata of the mutation.
func withOrgMetadata(node *OrgMetadata) orgmetadataOption {
	return func(m *OrgMetadataMutation) {
		m.oldValue = func(context.Context) (*OrgMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrgMetadataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgMetadataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgMetadata entity.
// If the OrgMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMetadataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgMetadataMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OrgMetadataMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrgMetadataMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrgMetadata entity.
// If the OrgMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMetadataMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrgMetadataMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[orgmetadata.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrgMetadataMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[orgmetadata.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrgMetadataMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, orgmetadata.FieldDescription)
}

// AddMetadatumIDs adds the "metadata" edge to the Metadata entity by ids.
func (m *OrgMetadataMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the Metadata entity.
func (m *OrgMetadataMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the Metadata entity was cleared.
func (m *OrgMetadataMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the Metadata entity by IDs.
func (m *OrgMetadataMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the Metadata entity.
func (m *OrgMetadataMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *OrgMetadataMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *OrgMetadataMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the OrgMetadataMutation builder.
func (m *OrgMetadataMutation) Where(ps ...predicate.OrgMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMetadataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMetadataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgMetadata, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMetadataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMetadataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgMetadata).
func (m *OrgMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMetadataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, orgmetadata.FieldName)
	}
	if m.description != nil {
		fields = append(fields, orgmetadata.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgmetadata.FieldName:
		return m.Name()
	case orgmetadata.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgmetadata.FieldName:
		return m.OldName(ctx)
	case orgmetadata.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown OrgMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgmetadata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgmetadata.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMetadataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgmetadata.FieldDescription) {
		fields = append(fields, orgmetadata.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMetadataMutation) ClearField(name string) error {
	switch name {
	case orgmetadata.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMetadataMutation) ResetField(name string) error {
	switch name {
	case orgmetadata.FieldName:
		m.ResetName()
		return nil
	case orgmetadata.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.metadata != nil {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgmetadata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmetadata != nil {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgmetadata.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmetadata {
		edges = append(edges, orgmetadata.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case orgmetadata.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMetadataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMetadataMutation) ResetEdge(name string) error {
	switch name {
	case orgmetadata.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown OrgMetadata edge %s", name)
}

// PrinterMutation represents an operation that mutates the Printer nodes in the graph.
type PrinterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	port          *string
	is_default    *bool
	is_network    *bool
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Printer, error)
	predicates    []predicate.Printer
}

var _ ent.Mutation = (*PrinterMutation)(nil)

// printerOption allows management of the mutation configuration using functional options.
type printerOption func(*PrinterMutation)

// newPrinterMutation creates new mutation for the Printer entity.
func newPrinterMutation(c config, op Op, opts ...printerOption) *PrinterMutation {
	m := &PrinterMutation{
		config:        c,
		op:            op,
		typ:           TypePrinter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrinterID sets the ID field of the mutation.
func withPrinterID(id int) printerOption {
	return func(m *PrinterMutation) {
		var (
			err   error
			once  sync.Once
			value *Printer
		)
		m.oldValue = func(ctx context.Context) (*Printer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Printer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrinter sets the old Printer of the mutation.
func withPrinter(node *Printer) printerOption {
	return func(m *PrinterMutation) {
		m.oldValue = func(context.Context) (*Printer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrinterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrinterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrinterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrinterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Printer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PrinterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PrinterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PrinterMutation) ResetName() {
	m.name = nil
}

// SetPort sets the "port" field.
func (m *PrinterMutation) SetPort(s string) {
	m.port = &s
}

// Port returns the value of the "port" field in the mutation.
func (m *PrinterMutation) Port() (r string, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ClearPort clears the value of the "port" field.
func (m *PrinterMutation) ClearPort() {
	m.port = nil
	m.clearedFields[printer.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *PrinterMutation) PortCleared() bool {
	_, ok := m.clearedFields[printer.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *PrinterMutation) ResetPort() {
	m.port = nil
	delete(m.clearedFields, printer.FieldPort)
}

// SetIsDefault sets the "is_default" field.
func (m *PrinterMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PrinterMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ClearIsDefault clears the value of the "is_default" field.
func (m *PrinterMutation) ClearIsDefault() {
	m.is_default = nil
	m.clearedFields[printer.FieldIsDefault] = struct{}{}
}

// IsDefaultCleared returns if the "is_default" field was cleared in this mutation.
func (m *PrinterMutation) IsDefaultCleared() bool {
	_, ok := m.clearedFields[printer.FieldIsDefault]
	return ok
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PrinterMutation) ResetIsDefault() {
	m.is_default = nil
	delete(m.clearedFields, printer.FieldIsDefault)
}

// SetIsNetwork sets the "is_network" field.
func (m *PrinterMutation) SetIsNetwork(b bool) {
	m.is_network = &b
}

// IsNetwork returns the value of the "is_network" field in the mutation.
func (m *PrinterMutation) IsNetwork() (r bool, exists bool) {
	v := m.is_network
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNetwork returns the old "is_network" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldIsNetwork(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNetwork: %w", err)
	}
	return oldValue.IsNetwork, nil
}

// ClearIsNetwork clears the value of the "is_network" field.
func (m *PrinterMutation) ClearIsNetwork() {
	m.is_network = nil
	m.clearedFields[printer.FieldIsNetwork] = struct{}{}
}

// IsNetworkCleared returns if the "is_network" field was cleared in this mutation.
func (m *PrinterMutation) IsNetworkCleared() bool {
	_, ok := m.clearedFields[printer.FieldIsNetwork]
	return ok
}

// ResetIsNetwork resets all changes to the "is_network" field.
func (m *PrinterMutation) ResetIsNetwork() {
	m.is_network = nil
	delete(m.clearedFields, printer.FieldIsNetwork)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *PrinterMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *PrinterMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *PrinterMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PrinterMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PrinterMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PrinterMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PrinterMutation builder.
func (m *PrinterMutation) Where(ps ...predicate.Printer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrinterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrinterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Printer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrinterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrinterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Printer).
func (m *PrinterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrinterMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, printer.FieldName)
	}
	if m.port != nil {
		fields = append(fields, printer.FieldPort)
	}
	if m.is_default != nil {
		fields = append(fields, printer.FieldIsDefault)
	}
	if m.is_network != nil {
		fields = append(fields, printer.FieldIsNetwork)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrinterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printer.FieldName:
		return m.Name()
	case printer.FieldPort:
		return m.Port()
	case printer.FieldIsDefault:
		return m.IsDefault()
	case printer.FieldIsNetwork:
		return m.IsNetwork()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrinterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printer.FieldName:
		return m.OldName(ctx)
	case printer.FieldPort:
		return m.OldPort(ctx)
	case printer.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case printer.FieldIsNetwork:
		return m.OldIsNetwork(ctx)
	}
	return nil, fmt.Errorf("unknown Printer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case printer.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case printer.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case printer.FieldIsNetwork:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNetwork(v)
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrinterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrinterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Printer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrinterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(printer.FieldPort) {
		fields = append(fields, printer.FieldPort)
	}
	if m.FieldCleared(printer.FieldIsDefault) {
		fields = append(fields, printer.FieldIsDefault)
	}
	if m.FieldCleared(printer.FieldIsNetwork) {
		fields = append(fields, printer.FieldIsNetwork)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrinterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrinterMutation) ClearField(name string) error {
	switch name {
	case printer.FieldPort:
		m.ClearPort()
		return nil
	case printer.FieldIsDefault:
		m.ClearIsDefault()
		return nil
	case printer.FieldIsNetwork:
		m.ClearIsNetwork()
		return nil
	}
	return fmt.Errorf("unknown Printer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrinterMutation) ResetField(name string) error {
	switch name {
	case printer.FieldName:
		m.ResetName()
		return nil
	case printer.FieldPort:
		m.ResetPort()
		return nil
	case printer.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case printer.FieldIsNetwork:
		m.ResetIsNetwork()
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrinterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, printer.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrinterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printer.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrinterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrinterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrinterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, printer.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrinterMutation) EdgeCleared(name string) bool {
	switch name {
	case printer.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrinterMutation) ClearEdge(name string) error {
	switch name {
	case printer.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Printer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrinterMutation) ResetEdge(name string) error {
	switch name {
	case printer.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Printer edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	release_type  *release.ReleaseType
	version       *string
	channel       *string
	summary       *string
	release_notes *string
	file_url      *string
	checksum      *string
	is_critical   *bool
	release_date  *time.Time
	os            *string
	arch          *string
	clearedFields map[string]struct{}
	agents        map[string]struct{}
	removedagents map[string]struct{}
	clearedagents bool
	done          bool
	oldValue      func(context.Context) (*Release, error)
	predicates    []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id int) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReleaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Release.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReleaseType sets the "release_type" field.
func (m *ReleaseMutation) SetReleaseType(rt release.ReleaseType) {
	m.release_type = &rt
}

// ReleaseType returns the value of the "release_type" field in the mutation.
func (m *ReleaseMutation) ReleaseType() (r release.ReleaseType, exists bool) {
	v := m.release_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseType returns the old "release_type" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseType(ctx context.Context) (v release.ReleaseType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseType: %w", err)
	}
	return oldValue.ReleaseType, nil
}

// ClearReleaseType clears the value of the "release_type" field.
func (m *ReleaseMutation) ClearReleaseType() {
	m.release_type = nil
	m.clearedFields[release.FieldReleaseType] = struct{}{}
}

// ReleaseTypeCleared returns if the "release_type" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseTypeCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseType]
	return ok
}

// ResetReleaseType resets all changes to the "release_type" field.
func (m *ReleaseMutation) ResetReleaseType() {
	m.release_type = nil
	delete(m.clearedFields, release.FieldReleaseType)
}

// SetVersion sets the "version" field.
func (m *ReleaseMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ReleaseMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ReleaseMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[release.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ReleaseMutation) VersionCleared() bool {
	_, ok := m.clearedFields[release.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ReleaseMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, release.FieldVersion)
}

// SetChannel sets the "channel" field.
func (m *ReleaseMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *ReleaseMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ClearChannel clears the value of the "channel" field.
func (m *ReleaseMutation) ClearChannel() {
	m.channel = nil
	m.clearedFields[release.FieldChannel] = struct{}{}
}

// ChannelCleared returns if the "channel" field was cleared in this mutation.
func (m *ReleaseMutation) ChannelCleared() bool {
	_, ok := m.clearedFields[release.FieldChannel]
	return ok
}

// ResetChannel resets all changes to the "channel" field.
func (m *ReleaseMutation) ResetChannel() {
	m.channel = nil
	delete(m.clearedFields, release.FieldChannel)
}

// SetSummary sets the "summary" field.
func (m *ReleaseMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *ReleaseMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *ReleaseMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[release.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *ReleaseMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[release.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *ReleaseMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, release.FieldSummary)
}

// SetReleaseNotes sets the "release_notes" field.
func (m *ReleaseMutation) SetReleaseNotes(s string) {
	m.release_notes = &s
}

// ReleaseNotes returns the value of the "release_notes" field in the mutation.
func (m *ReleaseMutation) ReleaseNotes() (r string, exists bool) {
	v := m.release_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseNotes returns the old "release_notes" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseNotes: %w", err)
	}
	return oldValue.ReleaseNotes, nil
}

// ClearReleaseNotes clears the value of the "release_notes" field.
func (m *ReleaseMutation) ClearReleaseNotes() {
	m.release_notes = nil
	m.clearedFields[release.FieldReleaseNotes] = struct{}{}
}

// ReleaseNotesCleared returns if the "release_notes" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseNotesCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseNotes]
	return ok
}

// ResetReleaseNotes resets all changes to the "release_notes" field.
func (m *ReleaseMutation) ResetReleaseNotes() {
	m.release_notes = nil
	delete(m.clearedFields, release.FieldReleaseNotes)
}

// SetFileURL sets the "file_url" field.
func (m *ReleaseMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ReleaseMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ClearFileURL clears the value of the "file_url" field.
func (m *ReleaseMutation) ClearFileURL() {
	m.file_url = nil
	m.clearedFields[release.FieldFileURL] = struct{}{}
}

// FileURLCleared returns if the "file_url" field was cleared in this mutation.
func (m *ReleaseMutation) FileURLCleared() bool {
	_, ok := m.clearedFields[release.FieldFileURL]
	return ok
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ReleaseMutation) ResetFileURL() {
	m.file_url = nil
	delete(m.clearedFields, release.FieldFileURL)
}

// SetChecksum sets the "checksum" field.
func (m *ReleaseMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *ReleaseMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *ReleaseMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[release.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *ReleaseMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[release.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *ReleaseMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, release.FieldChecksum)
}

// SetIsCritical sets the "is_critical" field.
func (m *ReleaseMutation) SetIsCritical(b bool) {
	m.is_critical = &b
}

// IsCritical returns the value of the "is_critical" field in the mutation.
func (m *ReleaseMutation) IsCritical() (r bool, exists bool) {
	v := m.is_critical
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCritical returns the old "is_critical" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldIsCritical(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCritical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCritical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCritical: %w", err)
	}
	return oldValue.IsCritical, nil
}

// ClearIsCritical clears the value of the "is_critical" field.
func (m *ReleaseMutation) ClearIsCritical() {
	m.is_critical = nil
	m.clearedFields[release.FieldIsCritical] = struct{}{}
}

// IsCriticalCleared returns if the "is_critical" field was cleared in this mutation.
func (m *ReleaseMutation) IsCriticalCleared() bool {
	_, ok := m.clearedFields[release.FieldIsCritical]
	return ok
}

// ResetIsCritical resets all changes to the "is_critical" field.
func (m *ReleaseMutation) ResetIsCritical() {
	m.is_critical = nil
	delete(m.clearedFields, release.FieldIsCritical)
}

// SetReleaseDate sets the "release_date" field.
func (m *ReleaseMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *ReleaseMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *ReleaseMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[release.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *ReleaseMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[release.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *ReleaseMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, release.FieldReleaseDate)
}

// SetOs sets the "os" field.
func (m *ReleaseMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *ReleaseMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *ReleaseMutation) ClearOs() {
	m.os = nil
	m.clearedFields[release.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *ReleaseMutation) OsCleared() bool {
	_, ok := m.clearedFields[release.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *ReleaseMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, release.FieldOs)
}

// SetArch sets the "arch" field.
func (m *ReleaseMutation) SetArch(s string) {
	m.arch = &s
}

// Arch returns the value of the "arch" field in the mutation.
func (m *ReleaseMutation) Arch() (r string, exists bool) {
	v := m.arch
	if v == nil {
		return
	}
	return *v, true
}

// OldArch returns the old "arch" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArch: %w", err)
	}
	return oldValue.Arch, nil
}

// ClearArch clears the value of the "arch" field.
func (m *ReleaseMutation) ClearArch() {
	m.arch = nil
	m.clearedFields[release.FieldArch] = struct{}{}
}

// ArchCleared returns if the "arch" field was cleared in this mutation.
func (m *ReleaseMutation) ArchCleared() bool {
	_, ok := m.clearedFields[release.FieldArch]
	return ok
}

// ResetArch resets all changes to the "arch" field.
func (m *ReleaseMutation) ResetArch() {
	m.arch = nil
	delete(m.clearedFields, release.FieldArch)
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *ReleaseMutation) AddAgentIDs(ids ...string) {
	if m.agents == nil {
		m.agents = make(map[string]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *ReleaseMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *ReleaseMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *ReleaseMutation) RemoveAgentIDs(ids ...string) {
	if m.removedagents == nil {
		m.removedagents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *ReleaseMutation) RemovedAgentsIDs() (ids []string) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *ReleaseMutation) AgentsIDs() (ids []string) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *ReleaseMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReleaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReleaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Release, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReleaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.release_type != nil {
		fields = append(fields, release.FieldReleaseType)
	}
	if m.version != nil {
		fields = append(fields, release.FieldVersion)
	}
	if m.channel != nil {
		fields = append(fields, release.FieldChannel)
	}
	if m.summary != nil {
		fields = append(fields, release.FieldSummary)
	}
	if m.release_notes != nil {
		fields = append(fields, release.FieldReleaseNotes)
	}
	if m.file_url != nil {
		fields = append(fields, release.FieldFileURL)
	}
	if m.checksum != nil {
		fields = append(fields, release.FieldChecksum)
	}
	if m.is_critical != nil {
		fields = append(fields, release.FieldIsCritical)
	}
	if m.release_date != nil {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m.os != nil {
		fields = append(fields, release.FieldOs)
	}
	if m.arch != nil {
		fields = append(fields, release.FieldArch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldReleaseType:
		return m.ReleaseType()
	case release.FieldVersion:
		return m.Version()
	case release.FieldChannel:
		return m.Channel()
	case release.FieldSummary:
		return m.Summary()
	case release.FieldReleaseNotes:
		return m.ReleaseNotes()
	case release.FieldFileURL:
		return m.FileURL()
	case release.FieldChecksum:
		return m.Checksum()
	case release.FieldIsCritical:
		return m.IsCritical()
	case release.FieldReleaseDate:
		return m.ReleaseDate()
	case release.FieldOs:
		return m.Os()
	case release.FieldArch:
		return m.Arch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldReleaseType:
		return m.OldReleaseType(ctx)
	case release.FieldVersion:
		return m.OldVersion(ctx)
	case release.FieldChannel:
		return m.OldChannel(ctx)
	case release.FieldSummary:
		return m.OldSummary(ctx)
	case release.FieldReleaseNotes:
		return m.OldReleaseNotes(ctx)
	case release.FieldFileURL:
		return m.OldFileURL(ctx)
	case release.FieldChecksum:
		return m.OldChecksum(ctx)
	case release.FieldIsCritical:
		return m.OldIsCritical(ctx)
	case release.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case release.FieldOs:
		return m.OldOs(ctx)
	case release.FieldArch:
		return m.OldArch(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldReleaseType:
		v, ok := value.(release.ReleaseType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseType(v)
		return nil
	case release.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case release.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case release.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case release.FieldReleaseNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseNotes(v)
		return nil
	case release.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case release.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case release.FieldIsCritical:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCritical(v)
		return nil
	case release.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case release.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case release.FieldArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArch(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(release.FieldReleaseType) {
		fields = append(fields, release.FieldReleaseType)
	}
	if m.FieldCleared(release.FieldVersion) {
		fields = append(fields, release.FieldVersion)
	}
	if m.FieldCleared(release.FieldChannel) {
		fields = append(fields, release.FieldChannel)
	}
	if m.FieldCleared(release.FieldSummary) {
		fields = append(fields, release.FieldSummary)
	}
	if m.FieldCleared(release.FieldReleaseNotes) {
		fields = append(fields, release.FieldReleaseNotes)
	}
	if m.FieldCleared(release.FieldFileURL) {
		fields = append(fields, release.FieldFileURL)
	}
	if m.FieldCleared(release.FieldChecksum) {
		fields = append(fields, release.FieldChecksum)
	}
	if m.FieldCleared(release.FieldIsCritical) {
		fields = append(fields, release.FieldIsCritical)
	}
	if m.FieldCleared(release.FieldReleaseDate) {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m.FieldCleared(release.FieldOs) {
		fields = append(fields, release.FieldOs)
	}
	if m.FieldCleared(release.FieldArch) {
		fields = append(fields, release.FieldArch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	switch name {
	case release.FieldReleaseType:
		m.ClearReleaseType()
		return nil
	case release.FieldVersion:
		m.ClearVersion()
		return nil
	case release.FieldChannel:
		m.ClearChannel()
		return nil
	case release.FieldSummary:
		m.ClearSummary()
		return nil
	case release.FieldReleaseNotes:
		m.ClearReleaseNotes()
		return nil
	case release.FieldFileURL:
		m.ClearFileURL()
		return nil
	case release.FieldChecksum:
		m.ClearChecksum()
		return nil
	case release.FieldIsCritical:
		m.ClearIsCritical()
		return nil
	case release.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case release.FieldOs:
		m.ClearOs()
		return nil
	case release.FieldArch:
		m.ClearArch()
		return nil
	}
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldReleaseType:
		m.ResetReleaseType()
		return nil
	case release.FieldVersion:
		m.ResetVersion()
		return nil
	case release.FieldChannel:
		m.ResetChannel()
		return nil
	case release.FieldSummary:
		m.ResetSummary()
		return nil
	case release.FieldReleaseNotes:
		m.ResetReleaseNotes()
		return nil
	case release.FieldFileURL:
		m.ResetFileURL()
		return nil
	case release.FieldChecksum:
		m.ResetChecksum()
		return nil
	case release.FieldIsCritical:
		m.ResetIsCritical()
		return nil
	case release.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case release.FieldOs:
		m.ResetOs()
		return nil
	case release.FieldArch:
		m.ResetArch()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.agents != nil {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedagents != nil {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedagents {
		edges = append(edges, release.EdgeAgents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeAgents:
		return m.clearedagents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeAgents:
		m.ResetAgents()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// RevocationMutation represents an operation that mutates the Revocation nodes in the graph.
type RevocationMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	reason        *int
	addreason     *int
	info          *string
	expiry        *time.Time
	revoked       *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Revocation, error)
	predicates    []predicate.Revocation
}

var _ ent.Mutation = (*RevocationMutation)(nil)

// revocationOption allows management of the mutation configuration using functional options.
type revocationOption func(*RevocationMutation)

// newRevocationMutation creates new mutation for the Revocation entity.
func newRevocationMutation(c config, op Op, opts ...revocationOption) *RevocationMutation {
	m := &RevocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRevocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevocationID sets the ID field of the mutation.
func withRevocationID(id int64) revocationOption {
	return func(m *RevocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Revocation
		)
		m.oldValue = func(ctx context.Context) (*Revocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevocation sets the old Revocation of the mutation.
func withRevocation(node *Revocation) revocationOption {
	return func(m *RevocationMutation) {
		m.oldValue = func(context.Context) (*Revocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Revocation entities.
func (m *RevocationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevocationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevocationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Revocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReason sets the "reason" field.
func (m *RevocationMutation) SetReason(i int) {
	m.reason = &i
	m.addreason = nil
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RevocationMutation) Reason() (r int, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldReason(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// AddReason adds i to the "reason" field.
func (m *RevocationMutation) AddReason(i int) {
	if m.addreason != nil {
		*m.addreason += i
	} else {
		m.addreason = &i
	}
}

// AddedReason returns the value that was added to the "reason" field in this mutation.
func (m *RevocationMutation) AddedReason() (r int, exists bool) {
	v := m.addreason
	if v == nil {
		return
	}
	return *v, true
}

// ClearReason clears the value of the "reason" field.
func (m *RevocationMutation) ClearReason() {
	m.reason = nil
	m.addreason = nil
	m.clearedFields[revocation.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *RevocationMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[revocation.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *RevocationMutation) ResetReason() {
	m.reason = nil
	m.addreason = nil
	delete(m.clearedFields, revocation.FieldReason)
}

// SetInfo sets the "info" field.
func (m *RevocationMutation) SetInfo(s string) {
	m.info = &s
}

// Info returns the value of the "info" field in the mutation.
func (m *RevocationMutation) Info() (r string, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *RevocationMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[revocation.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *RevocationMutation) InfoCleared() bool {
	_, ok := m.clearedFields[revocation.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *RevocationMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, revocation.FieldInfo)
}

// SetExpiry sets the "expiry" field.
func (m *RevocationMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *RevocationMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *RevocationMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[revocation.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *RevocationMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[revocation.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *RevocationMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, revocation.FieldExpiry)
}

// SetRevoked sets the "revoked" field.
func (m *RevocationMutation) SetRevoked(t time.Time) {
	m.revoked = &t
}

// Revoked returns the value of the "revoked" field in the mutation.
func (m *RevocationMutation) Revoked() (r time.Time, exists bool) {
	v := m.revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldRevoked returns the old "revoked" field's value of the Revocation entity.
// If the Revocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevocationMutation) OldRevoked(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
	}
	return oldValue.Revoked, nil
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *RevocationMutation) ResetRevoked() {
	m.revoked = nil
}

// Where appends a list predicates to the RevocationMutation builder.
func (m *RevocationMutation) Where(ps ...predicate.Revocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Revocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Revocation).
func (m *RevocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.reason != nil {
		fields = append(fields, revocation.FieldReason)
	}
	if m.info != nil {
		fields = append(fields, revocation.FieldInfo)
	}
	if m.expiry != nil {
		fields = append(fields, revocation.FieldExpiry)
	}
	if m.revoked != nil {
		fields = append(fields, revocation.FieldRevoked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revocation.FieldReason:
		return m.Reason()
	case revocation.FieldInfo:
		return m.Info()
	case revocation.FieldExpiry:
		return m.Expiry()
	case revocation.FieldRevoked:
		return m.Revoked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revocation.FieldReason:
		return m.OldReason(ctx)
	case revocation.FieldInfo:
		return m.OldInfo(ctx)
	case revocation.FieldExpiry:
		return m.OldExpiry(ctx)
	case revocation.FieldRevoked:
		return m.OldRevoked(ctx)
	}
	return nil, fmt.Errorf("unknown Revocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revocation.FieldReason:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case revocation.FieldInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case revocation.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case revocation.FieldRevoked:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevoked(v)
		return nil
	}
	return fmt.Errorf("unknown Revocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevocationMutation) AddedFields() []string {
	var fields []string
	if m.addreason != nil {
		fields = append(fields, revocation.FieldReason)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case revocation.FieldReason:
		return m.AddedReason()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case revocation.FieldReason:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReason(v)
		return nil
	}
	return fmt.Errorf("unknown Revocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revocation.FieldReason) {
		fields = append(fields, revocation.FieldReason)
	}
	if m.FieldCleared(revocation.FieldInfo) {
		fields = append(fields, revocation.FieldInfo)
	}
	if m.FieldCleared(revocation.FieldExpiry) {
		fields = append(fields, revocation.FieldExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevocationMutation) ClearField(name string) error {
	switch name {
	case revocation.FieldReason:
		m.ClearReason()
		return nil
	case revocation.FieldInfo:
		m.ClearInfo()
		return nil
	case revocation.FieldExpiry:
		m.ClearExpiry()
		return nil
	}
	return fmt.Errorf("unknown Revocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevocationMutation) ResetField(name string) error {
	switch name {
	case revocation.FieldReason:
		m.ResetReason()
		return nil
	case revocation.FieldInfo:
		m.ResetInfo()
		return nil
	case revocation.FieldExpiry:
		m.ResetExpiry()
		return nil
	case revocation.FieldRevoked:
		m.ResetRevoked()
		return nil
	}
	return fmt.Errorf("unknown Revocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Revocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Revocation edge %s", name)
}

// SessionsMutation represents an operation that mutates the Sessions nodes in the graph.
type SessionsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	data          *[]byte
	expiry        *time.Time
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Sessions, error)
	predicates    []predicate.Sessions
}

var _ ent.Mutation = (*SessionsMutation)(nil)

// sessionsOption allows management of the mutation configuration using functional options.
type sessionsOption func(*SessionsMutation)

// newSessionsMutation creates new mutation for the Sessions entity.
func newSessionsMutation(c config, op Op, opts ...sessionsOption) *SessionsMutation {
	m := &SessionsMutation{
		config:        c,
		op:            op,
		typ:           TypeSessions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionsID sets the ID field of the mutation.
func withSessionsID(id string) sessionsOption {
	return func(m *SessionsMutation) {
		var (
			err   error
			once  sync.Once
			value *Sessions
		)
		m.oldValue = func(ctx context.Context) (*Sessions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sessions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSessions sets the old Sessions of the mutation.
func withSessions(node *Sessions) sessionsOption {
	return func(m *SessionsMutation) {
		m.oldValue = func(context.Context) (*Sessions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sessions entities.
func (m *SessionsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sessions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *SessionsMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *SessionsMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Sessions entity.
// If the Sessions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionsMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SessionsMutation) ResetData() {
	m.data = nil
}

// SetExpiry sets the "expiry" field.
func (m *SessionsMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *SessionsMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the Sessions entity.
// If the Sessions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionsMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *SessionsMutation) ResetExpiry() {
	m.expiry = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SessionsMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SessionsMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SessionsMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SessionsMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SessionsMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SessionsMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SessionsMutation builder.
func (m *SessionsMutation) Where(ps ...predicate.Sessions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sessions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sessions).
func (m *SessionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.data != nil {
		fields = append(fields, sessions.FieldData)
	}
	if m.expiry != nil {
		fields = append(fields, sessions.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sessions.FieldData:
		return m.Data()
	case sessions.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sessions.FieldData:
		return m.OldData(ctx)
	case sessions.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown Sessions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sessions.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case sessions.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Sessions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sessions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Sessions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionsMutation) ResetField(name string) error {
	switch name {
	case sessions.FieldData:
		m.ResetData()
		return nil
	case sessions.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Sessions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, sessions.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sessions.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, sessions.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionsMutation) EdgeCleared(name string) bool {
	switch name {
	case sessions.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionsMutation) ClearEdge(name string) error {
	switch name {
	case sessions.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Sessions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionsMutation) ResetEdge(name string) error {
	switch name {
	case sessions.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Sessions edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	language                             *string
	organization                         *string
	postal_address                       *string
	postal_code                          *string
	locality                             *string
	province                             *string
	state                                *string
	country                              *string
	smtp_server                          *string
	smtp_port                            *int
	addsmtp_port                         *int
	smtp_user                            *string
	smtp_password                        *string
	smtp_auth                            *string
	smtp_tls                             *bool
	smtp_starttls                        *bool
	nats_server                          *string
	nats_port                            *string
	message_from                         *string
	max_upload_size                      *string
	user_cert_years_valid                *int
	adduser_cert_years_valid             *int
	nats_request_timeout_seconds         *int
	addnats_request_timeout_seconds      *int
	refresh_time_in_minutes              *int
	addrefresh_time_in_minutes           *int
	session_lifetime_in_minutes          *int
	addsession_lifetime_in_minutes       *int
	update_channel                       *string
	created                              *time.Time
	modified                             *time.Time
	agent_report_frequence_in_minutes    *int
	addagent_report_frequence_in_minutes *int
	clearedFields                        map[string]struct{}
	done                                 bool
	oldValue                             func(context.Context) (*Settings, error)
	predicates                           []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguage sets the "language" field.
func (m *SettingsMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *SettingsMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *SettingsMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[settings.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *SettingsMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[settings.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *SettingsMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, settings.FieldLanguage)
}

// SetOrganization sets the "organization" field.
func (m *SettingsMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *SettingsMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ClearOrganization clears the value of the "organization" field.
func (m *SettingsMutation) ClearOrganization() {
	m.organization = nil
	m.clearedFields[settings.FieldOrganization] = struct{}{}
}

// OrganizationCleared returns if the "organization" field was cleared in this mutation.
func (m *SettingsMutation) OrganizationCleared() bool {
	_, ok := m.clearedFields[settings.FieldOrganization]
	return ok
}

// ResetOrganization resets all changes to the "organization" field.
func (m *SettingsMutation) ResetOrganization() {
	m.organization = nil
	delete(m.clearedFields, settings.FieldOrganization)
}

// SetPostalAddress sets the "postal_address" field.
func (m *SettingsMutation) SetPostalAddress(s string) {
	m.postal_address = &s
}

// PostalAddress returns the value of the "postal_address" field in the mutation.
func (m *SettingsMutation) PostalAddress() (r string, exists bool) {
	v := m.postal_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalAddress returns the old "postal_address" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldPostalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalAddress: %w", err)
	}
	return oldValue.PostalAddress, nil
}

// ClearPostalAddress clears the value of the "postal_address" field.
func (m *SettingsMutation) ClearPostalAddress() {
	m.postal_address = nil
	m.clearedFields[settings.FieldPostalAddress] = struct{}{}
}

// PostalAddressCleared returns if the "postal_address" field was cleared in this mutation.
func (m *SettingsMutation) PostalAddressCleared() bool {
	_, ok := m.clearedFields[settings.FieldPostalAddress]
	return ok
}

// ResetPostalAddress resets all changes to the "postal_address" field.
func (m *SettingsMutation) ResetPostalAddress() {
	m.postal_address = nil
	delete(m.clearedFields, settings.FieldPostalAddress)
}

// SetPostalCode sets the "postal_code" field.
func (m *SettingsMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *SettingsMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *SettingsMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[settings.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *SettingsMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[settings.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *SettingsMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, settings.FieldPostalCode)
}

// SetLocality sets the "locality" field.
func (m *SettingsMutation) SetLocality(s string) {
	m.locality = &s
}

// Locality returns the value of the "locality" field in the mutation.
func (m *SettingsMutation) Locality() (r string, exists bool) {
	v := m.locality
	if v == nil {
		return
	}
	return *v, true
}

// OldLocality returns the old "locality" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldLocality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocality: %w", err)
	}
	return oldValue.Locality, nil
}

// ClearLocality clears the value of the "locality" field.
func (m *SettingsMutation) ClearLocality() {
	m.locality = nil
	m.clearedFields[settings.FieldLocality] = struct{}{}
}

// LocalityCleared returns if the "locality" field was cleared in this mutation.
func (m *SettingsMutation) LocalityCleared() bool {
	_, ok := m.clearedFields[settings.FieldLocality]
	return ok
}

// ResetLocality resets all changes to the "locality" field.
func (m *SettingsMutation) ResetLocality() {
	m.locality = nil
	delete(m.clearedFields, settings.FieldLocality)
}

// SetProvince sets the "province" field.
func (m *SettingsMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *SettingsMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *SettingsMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[settings.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *SettingsMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[settings.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *SettingsMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, settings.FieldProvince)
}

// SetState sets the "state" field.
func (m *SettingsMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *SettingsMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *SettingsMutation) ClearState() {
	m.state = nil
	m.clearedFields[settings.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *SettingsMutation) StateCleared() bool {
	_, ok := m.clearedFields[settings.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *SettingsMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, settings.FieldState)
}

// SetCountry sets the "country" field.
func (m *SettingsMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *SettingsMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *SettingsMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[settings.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *SettingsMutation) CountryCleared() bool {
	_, ok := m.clearedFields[settings.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *SettingsMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, settings.FieldCountry)
}

// SetSMTPServer sets the "smtp_server" field.
func (m *SettingsMutation) SetSMTPServer(s string) {
	m.smtp_server = &s
}

// SMTPServer returns the value of the "smtp_server" field in the mutation.
func (m *SettingsMutation) SMTPServer() (r string, exists bool) {
	v := m.smtp_server
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPServer returns the old "smtp_server" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPServer: %w", err)
	}
	return oldValue.SMTPServer, nil
}

// ClearSMTPServer clears the value of the "smtp_server" field.
func (m *SettingsMutation) ClearSMTPServer() {
	m.smtp_server = nil
	m.clearedFields[settings.FieldSMTPServer] = struct{}{}
}

// SMTPServerCleared returns if the "smtp_server" field was cleared in this mutation.
func (m *SettingsMutation) SMTPServerCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPServer]
	return ok
}

// ResetSMTPServer resets all changes to the "smtp_server" field.
func (m *SettingsMutation) ResetSMTPServer() {
	m.smtp_server = nil
	delete(m.clearedFields, settings.FieldSMTPServer)
}

// SetSMTPPort sets the "smtp_port" field.
func (m *SettingsMutation) SetSMTPPort(i int) {
	m.smtp_port = &i
	m.addsmtp_port = nil
}

// SMTPPort returns the value of the "smtp_port" field in the mutation.
func (m *SettingsMutation) SMTPPort() (r int, exists bool) {
	v := m.smtp_port
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPort returns the old "smtp_port" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPort: %w", err)
	}
	return oldValue.SMTPPort, nil
}

// AddSMTPPort adds i to the "smtp_port" field.
func (m *SettingsMutation) AddSMTPPort(i int) {
	if m.addsmtp_port != nil {
		*m.addsmtp_port += i
	} else {
		m.addsmtp_port = &i
	}
}

// AddedSMTPPort returns the value that was added to the "smtp_port" field in this mutation.
func (m *SettingsMutation) AddedSMTPPort() (r int, exists bool) {
	v := m.addsmtp_port
	if v == nil {
		return
	}
	return *v, true
}

// ClearSMTPPort clears the value of the "smtp_port" field.
func (m *SettingsMutation) ClearSMTPPort() {
	m.smtp_port = nil
	m.addsmtp_port = nil
	m.clearedFields[settings.FieldSMTPPort] = struct{}{}
}

// SMTPPortCleared returns if the "smtp_port" field was cleared in this mutation.
func (m *SettingsMutation) SMTPPortCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPPort]
	return ok
}

// ResetSMTPPort resets all changes to the "smtp_port" field.
func (m *SettingsMutation) ResetSMTPPort() {
	m.smtp_port = nil
	m.addsmtp_port = nil
	delete(m.clearedFields, settings.FieldSMTPPort)
}

// SetSMTPUser sets the "smtp_user" field.
func (m *SettingsMutation) SetSMTPUser(s string) {
	m.smtp_user = &s
}

// SMTPUser returns the value of the "smtp_user" field in the mutation.
func (m *SettingsMutation) SMTPUser() (r string, exists bool) {
	v := m.smtp_user
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPUser returns the old "smtp_user" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPUser: %w", err)
	}
	return oldValue.SMTPUser, nil
}

// ClearSMTPUser clears the value of the "smtp_user" field.
func (m *SettingsMutation) ClearSMTPUser() {
	m.smtp_user = nil
	m.clearedFields[settings.FieldSMTPUser] = struct{}{}
}

// SMTPUserCleared returns if the "smtp_user" field was cleared in this mutation.
func (m *SettingsMutation) SMTPUserCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPUser]
	return ok
}

// ResetSMTPUser resets all changes to the "smtp_user" field.
func (m *SettingsMutation) ResetSMTPUser() {
	m.smtp_user = nil
	delete(m.clearedFields, settings.FieldSMTPUser)
}

// SetSMTPPassword sets the "smtp_password" field.
func (m *SettingsMutation) SetSMTPPassword(s string) {
	m.smtp_password = &s
}

// SMTPPassword returns the value of the "smtp_password" field in the mutation.
func (m *SettingsMutation) SMTPPassword() (r string, exists bool) {
	v := m.smtp_password
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPPassword returns the old "smtp_password" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPPassword: %w", err)
	}
	return oldValue.SMTPPassword, nil
}

// ClearSMTPPassword clears the value of the "smtp_password" field.
func (m *SettingsMutation) ClearSMTPPassword() {
	m.smtp_password = nil
	m.clearedFields[settings.FieldSMTPPassword] = struct{}{}
}

// SMTPPasswordCleared returns if the "smtp_password" field was cleared in this mutation.
func (m *SettingsMutation) SMTPPasswordCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPPassword]
	return ok
}

// ResetSMTPPassword resets all changes to the "smtp_password" field.
func (m *SettingsMutation) ResetSMTPPassword() {
	m.smtp_password = nil
	delete(m.clearedFields, settings.FieldSMTPPassword)
}

// SetSMTPAuth sets the "smtp_auth" field.
func (m *SettingsMutation) SetSMTPAuth(s string) {
	m.smtp_auth = &s
}

// SMTPAuth returns the value of the "smtp_auth" field in the mutation.
func (m *SettingsMutation) SMTPAuth() (r string, exists bool) {
	v := m.smtp_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPAuth returns the old "smtp_auth" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPAuth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPAuth: %w", err)
	}
	return oldValue.SMTPAuth, nil
}

// ClearSMTPAuth clears the value of the "smtp_auth" field.
func (m *SettingsMutation) ClearSMTPAuth() {
	m.smtp_auth = nil
	m.clearedFields[settings.FieldSMTPAuth] = struct{}{}
}

// SMTPAuthCleared returns if the "smtp_auth" field was cleared in this mutation.
func (m *SettingsMutation) SMTPAuthCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPAuth]
	return ok
}

// ResetSMTPAuth resets all changes to the "smtp_auth" field.
func (m *SettingsMutation) ResetSMTPAuth() {
	m.smtp_auth = nil
	delete(m.clearedFields, settings.FieldSMTPAuth)
}

// SetSMTPTLS sets the "smtp_tls" field.
func (m *SettingsMutation) SetSMTPTLS(b bool) {
	m.smtp_tls = &b
}

// SMTPTLS returns the value of the "smtp_tls" field in the mutation.
func (m *SettingsMutation) SMTPTLS() (r bool, exists bool) {
	v := m.smtp_tls
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPTLS returns the old "smtp_tls" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPTLS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPTLS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPTLS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPTLS: %w", err)
	}
	return oldValue.SMTPTLS, nil
}

// ClearSMTPTLS clears the value of the "smtp_tls" field.
func (m *SettingsMutation) ClearSMTPTLS() {
	m.smtp_tls = nil
	m.clearedFields[settings.FieldSMTPTLS] = struct{}{}
}

// SMTPTLSCleared returns if the "smtp_tls" field was cleared in this mutation.
func (m *SettingsMutation) SMTPTLSCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPTLS]
	return ok
}

// ResetSMTPTLS resets all changes to the "smtp_tls" field.
func (m *SettingsMutation) ResetSMTPTLS() {
	m.smtp_tls = nil
	delete(m.clearedFields, settings.FieldSMTPTLS)
}

// SetSMTPStarttls sets the "smtp_starttls" field.
func (m *SettingsMutation) SetSMTPStarttls(b bool) {
	m.smtp_starttls = &b
}

// SMTPStarttls returns the value of the "smtp_starttls" field in the mutation.
func (m *SettingsMutation) SMTPStarttls() (r bool, exists bool) {
	v := m.smtp_starttls
	if v == nil {
		return
	}
	return *v, true
}

// OldSMTPStarttls returns the old "smtp_starttls" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSMTPStarttls(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSMTPStarttls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSMTPStarttls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSMTPStarttls: %w", err)
	}
	return oldValue.SMTPStarttls, nil
}

// ClearSMTPStarttls clears the value of the "smtp_starttls" field.
func (m *SettingsMutation) ClearSMTPStarttls() {
	m.smtp_starttls = nil
	m.clearedFields[settings.FieldSMTPStarttls] = struct{}{}
}

// SMTPStarttlsCleared returns if the "smtp_starttls" field was cleared in this mutation.
func (m *SettingsMutation) SMTPStarttlsCleared() bool {
	_, ok := m.clearedFields[settings.FieldSMTPStarttls]
	return ok
}

// ResetSMTPStarttls resets all changes to the "smtp_starttls" field.
func (m *SettingsMutation) ResetSMTPStarttls() {
	m.smtp_starttls = nil
	delete(m.clearedFields, settings.FieldSMTPStarttls)
}

// SetNatsServer sets the "nats_server" field.
func (m *SettingsMutation) SetNatsServer(s string) {
	m.nats_server = &s
}

// NatsServer returns the value of the "nats_server" field in the mutation.
func (m *SettingsMutation) NatsServer() (r string, exists bool) {
	v := m.nats_server
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsServer returns the old "nats_server" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsServer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsServer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsServer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsServer: %w", err)
	}
	return oldValue.NatsServer, nil
}

// ClearNatsServer clears the value of the "nats_server" field.
func (m *SettingsMutation) ClearNatsServer() {
	m.nats_server = nil
	m.clearedFields[settings.FieldNatsServer] = struct{}{}
}

// NatsServerCleared returns if the "nats_server" field was cleared in this mutation.
func (m *SettingsMutation) NatsServerCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsServer]
	return ok
}

// ResetNatsServer resets all changes to the "nats_server" field.
func (m *SettingsMutation) ResetNatsServer() {
	m.nats_server = nil
	delete(m.clearedFields, settings.FieldNatsServer)
}

// SetNatsPort sets the "nats_port" field.
func (m *SettingsMutation) SetNatsPort(s string) {
	m.nats_port = &s
}

// NatsPort returns the value of the "nats_port" field in the mutation.
func (m *SettingsMutation) NatsPort() (r string, exists bool) {
	v := m.nats_port
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsPort returns the old "nats_port" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsPort: %w", err)
	}
	return oldValue.NatsPort, nil
}

// ClearNatsPort clears the value of the "nats_port" field.
func (m *SettingsMutation) ClearNatsPort() {
	m.nats_port = nil
	m.clearedFields[settings.FieldNatsPort] = struct{}{}
}

// NatsPortCleared returns if the "nats_port" field was cleared in this mutation.
func (m *SettingsMutation) NatsPortCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsPort]
	return ok
}

// ResetNatsPort resets all changes to the "nats_port" field.
func (m *SettingsMutation) ResetNatsPort() {
	m.nats_port = nil
	delete(m.clearedFields, settings.FieldNatsPort)
}

// SetMessageFrom sets the "message_from" field.
func (m *SettingsMutation) SetMessageFrom(s string) {
	m.message_from = &s
}

// MessageFrom returns the value of the "message_from" field in the mutation.
func (m *SettingsMutation) MessageFrom() (r string, exists bool) {
	v := m.message_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageFrom returns the old "message_from" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMessageFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageFrom: %w", err)
	}
	return oldValue.MessageFrom, nil
}

// ClearMessageFrom clears the value of the "message_from" field.
func (m *SettingsMutation) ClearMessageFrom() {
	m.message_from = nil
	m.clearedFields[settings.FieldMessageFrom] = struct{}{}
}

// MessageFromCleared returns if the "message_from" field was cleared in this mutation.
func (m *SettingsMutation) MessageFromCleared() bool {
	_, ok := m.clearedFields[settings.FieldMessageFrom]
	return ok
}

// ResetMessageFrom resets all changes to the "message_from" field.
func (m *SettingsMutation) ResetMessageFrom() {
	m.message_from = nil
	delete(m.clearedFields, settings.FieldMessageFrom)
}

// SetMaxUploadSize sets the "max_upload_size" field.
func (m *SettingsMutation) SetMaxUploadSize(s string) {
	m.max_upload_size = &s
}

// MaxUploadSize returns the value of the "max_upload_size" field in the mutation.
func (m *SettingsMutation) MaxUploadSize() (r string, exists bool) {
	v := m.max_upload_size
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUploadSize returns the old "max_upload_size" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldMaxUploadSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUploadSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUploadSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUploadSize: %w", err)
	}
	return oldValue.MaxUploadSize, nil
}

// ClearMaxUploadSize clears the value of the "max_upload_size" field.
func (m *SettingsMutation) ClearMaxUploadSize() {
	m.max_upload_size = nil
	m.clearedFields[settings.FieldMaxUploadSize] = struct{}{}
}

// MaxUploadSizeCleared returns if the "max_upload_size" field was cleared in this mutation.
func (m *SettingsMutation) MaxUploadSizeCleared() bool {
	_, ok := m.clearedFields[settings.FieldMaxUploadSize]
	return ok
}

// ResetMaxUploadSize resets all changes to the "max_upload_size" field.
func (m *SettingsMutation) ResetMaxUploadSize() {
	m.max_upload_size = nil
	delete(m.clearedFields, settings.FieldMaxUploadSize)
}

// SetUserCertYearsValid sets the "user_cert_years_valid" field.
func (m *SettingsMutation) SetUserCertYearsValid(i int) {
	m.user_cert_years_valid = &i
	m.adduser_cert_years_valid = nil
}

// UserCertYearsValid returns the value of the "user_cert_years_valid" field in the mutation.
func (m *SettingsMutation) UserCertYearsValid() (r int, exists bool) {
	v := m.user_cert_years_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCertYearsValid returns the old "user_cert_years_valid" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUserCertYearsValid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCertYearsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCertYearsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCertYearsValid: %w", err)
	}
	return oldValue.UserCertYearsValid, nil
}

// AddUserCertYearsValid adds i to the "user_cert_years_valid" field.
func (m *SettingsMutation) AddUserCertYearsValid(i int) {
	if m.adduser_cert_years_valid != nil {
		*m.adduser_cert_years_valid += i
	} else {
		m.adduser_cert_years_valid = &i
	}
}

// AddedUserCertYearsValid returns the value that was added to the "user_cert_years_valid" field in this mutation.
func (m *SettingsMutation) AddedUserCertYearsValid() (r int, exists bool) {
	v := m.adduser_cert_years_valid
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserCertYearsValid clears the value of the "user_cert_years_valid" field.
func (m *SettingsMutation) ClearUserCertYearsValid() {
	m.user_cert_years_valid = nil
	m.adduser_cert_years_valid = nil
	m.clearedFields[settings.FieldUserCertYearsValid] = struct{}{}
}

// UserCertYearsValidCleared returns if the "user_cert_years_valid" field was cleared in this mutation.
func (m *SettingsMutation) UserCertYearsValidCleared() bool {
	_, ok := m.clearedFields[settings.FieldUserCertYearsValid]
	return ok
}

// ResetUserCertYearsValid resets all changes to the "user_cert_years_valid" field.
func (m *SettingsMutation) ResetUserCertYearsValid() {
	m.user_cert_years_valid = nil
	m.adduser_cert_years_valid = nil
	delete(m.clearedFields, settings.FieldUserCertYearsValid)
}

// SetNatsRequestTimeoutSeconds sets the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) SetNatsRequestTimeoutSeconds(i int) {
	m.nats_request_timeout_seconds = &i
	m.addnats_request_timeout_seconds = nil
}

// NatsRequestTimeoutSeconds returns the value of the "nats_request_timeout_seconds" field in the mutation.
func (m *SettingsMutation) NatsRequestTimeoutSeconds() (r int, exists bool) {
	v := m.nats_request_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldNatsRequestTimeoutSeconds returns the old "nats_request_timeout_seconds" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldNatsRequestTimeoutSeconds(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNatsRequestTimeoutSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNatsRequestTimeoutSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNatsRequestTimeoutSeconds: %w", err)
	}
	return oldValue.NatsRequestTimeoutSeconds, nil
}

// AddNatsRequestTimeoutSeconds adds i to the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) AddNatsRequestTimeoutSeconds(i int) {
	if m.addnats_request_timeout_seconds != nil {
		*m.addnats_request_timeout_seconds += i
	} else {
		m.addnats_request_timeout_seconds = &i
	}
}

// AddedNatsRequestTimeoutSeconds returns the value that was added to the "nats_request_timeout_seconds" field in this mutation.
func (m *SettingsMutation) AddedNatsRequestTimeoutSeconds() (r int, exists bool) {
	v := m.addnats_request_timeout_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearNatsRequestTimeoutSeconds clears the value of the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) ClearNatsRequestTimeoutSeconds() {
	m.nats_request_timeout_seconds = nil
	m.addnats_request_timeout_seconds = nil
	m.clearedFields[settings.FieldNatsRequestTimeoutSeconds] = struct{}{}
}

// NatsRequestTimeoutSecondsCleared returns if the "nats_request_timeout_seconds" field was cleared in this mutation.
func (m *SettingsMutation) NatsRequestTimeoutSecondsCleared() bool {
	_, ok := m.clearedFields[settings.FieldNatsRequestTimeoutSeconds]
	return ok
}

// ResetNatsRequestTimeoutSeconds resets all changes to the "nats_request_timeout_seconds" field.
func (m *SettingsMutation) ResetNatsRequestTimeoutSeconds() {
	m.nats_request_timeout_seconds = nil
	m.addnats_request_timeout_seconds = nil
	delete(m.clearedFields, settings.FieldNatsRequestTimeoutSeconds)
}

// SetRefreshTimeInMinutes sets the "refresh_time_in_minutes" field.
func (m *SettingsMutation) SetRefreshTimeInMinutes(i int) {
	m.refresh_time_in_minutes = &i
	m.addrefresh_time_in_minutes = nil
}

// RefreshTimeInMinutes returns the value of the "refresh_time_in_minutes" field in the mutation.
func (m *SettingsMutation) RefreshTimeInMinutes() (r int, exists bool) {
	v := m.refresh_time_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTimeInMinutes returns the old "refresh_time_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldRefreshTimeInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTimeInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTimeInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTimeInMinutes: %w", err)
	}
	return oldValue.RefreshTimeInMinutes, nil
}

// AddRefreshTimeInMinutes adds i to the "refresh_time_in_minutes" field.
func (m *SettingsMutation) AddRefreshTimeInMinutes(i int) {
	if m.addrefresh_time_in_minutes != nil {
		*m.addrefresh_time_in_minutes += i
	} else {
		m.addrefresh_time_in_minutes = &i
	}
}

// AddedRefreshTimeInMinutes returns the value that was added to the "refresh_time_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedRefreshTimeInMinutes() (r int, exists bool) {
	v := m.addrefresh_time_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshTimeInMinutes clears the value of the "refresh_time_in_minutes" field.
func (m *SettingsMutation) ClearRefreshTimeInMinutes() {
	m.refresh_time_in_minutes = nil
	m.addrefresh_time_in_minutes = nil
	m.clearedFields[settings.FieldRefreshTimeInMinutes] = struct{}{}
}

// RefreshTimeInMinutesCleared returns if the "refresh_time_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) RefreshTimeInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldRefreshTimeInMinutes]
	return ok
}

// ResetRefreshTimeInMinutes resets all changes to the "refresh_time_in_minutes" field.
func (m *SettingsMutation) ResetRefreshTimeInMinutes() {
	m.refresh_time_in_minutes = nil
	m.addrefresh_time_in_minutes = nil
	delete(m.clearedFields, settings.FieldRefreshTimeInMinutes)
}

// SetSessionLifetimeInMinutes sets the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) SetSessionLifetimeInMinutes(i int) {
	m.session_lifetime_in_minutes = &i
	m.addsession_lifetime_in_minutes = nil
}

// SessionLifetimeInMinutes returns the value of the "session_lifetime_in_minutes" field in the mutation.
func (m *SettingsMutation) SessionLifetimeInMinutes() (r int, exists bool) {
	v := m.session_lifetime_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionLifetimeInMinutes returns the old "session_lifetime_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSessionLifetimeInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionLifetimeInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionLifetimeInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionLifetimeInMinutes: %w", err)
	}
	return oldValue.SessionLifetimeInMinutes, nil
}

// AddSessionLifetimeInMinutes adds i to the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) AddSessionLifetimeInMinutes(i int) {
	if m.addsession_lifetime_in_minutes != nil {
		*m.addsession_lifetime_in_minutes += i
	} else {
		m.addsession_lifetime_in_minutes = &i
	}
}

// AddedSessionLifetimeInMinutes returns the value that was added to the "session_lifetime_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedSessionLifetimeInMinutes() (r int, exists bool) {
	v := m.addsession_lifetime_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSessionLifetimeInMinutes clears the value of the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) ClearSessionLifetimeInMinutes() {
	m.session_lifetime_in_minutes = nil
	m.addsession_lifetime_in_minutes = nil
	m.clearedFields[settings.FieldSessionLifetimeInMinutes] = struct{}{}
}

// SessionLifetimeInMinutesCleared returns if the "session_lifetime_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) SessionLifetimeInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldSessionLifetimeInMinutes]
	return ok
}

// ResetSessionLifetimeInMinutes resets all changes to the "session_lifetime_in_minutes" field.
func (m *SettingsMutation) ResetSessionLifetimeInMinutes() {
	m.session_lifetime_in_minutes = nil
	m.addsession_lifetime_in_minutes = nil
	delete(m.clearedFields, settings.FieldSessionLifetimeInMinutes)
}

// SetUpdateChannel sets the "update_channel" field.
func (m *SettingsMutation) SetUpdateChannel(s string) {
	m.update_channel = &s
}

// UpdateChannel returns the value of the "update_channel" field in the mutation.
func (m *SettingsMutation) UpdateChannel() (r string, exists bool) {
	v := m.update_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateChannel returns the old "update_channel" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdateChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateChannel: %w", err)
	}
	return oldValue.UpdateChannel, nil
}

// ClearUpdateChannel clears the value of the "update_channel" field.
func (m *SettingsMutation) ClearUpdateChannel() {
	m.update_channel = nil
	m.clearedFields[settings.FieldUpdateChannel] = struct{}{}
}

// UpdateChannelCleared returns if the "update_channel" field was cleared in this mutation.
func (m *SettingsMutation) UpdateChannelCleared() bool {
	_, ok := m.clearedFields[settings.FieldUpdateChannel]
	return ok
}

// ResetUpdateChannel resets all changes to the "update_channel" field.
func (m *SettingsMutation) ResetUpdateChannel() {
	m.update_channel = nil
	delete(m.clearedFields, settings.FieldUpdateChannel)
}

// SetCreated sets the "created" field.
func (m *SettingsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *SettingsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *SettingsMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[settings.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *SettingsMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[settings.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *SettingsMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, settings.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *SettingsMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *SettingsMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *SettingsMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[settings.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *SettingsMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[settings.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *SettingsMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, settings.FieldModified)
}

// SetAgentReportFrequenceInMinutes sets the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) SetAgentReportFrequenceInMinutes(i int) {
	m.agent_report_frequence_in_minutes = &i
	m.addagent_report_frequence_in_minutes = nil
}

// AgentReportFrequenceInMinutes returns the value of the "agent_report_frequence_in_minutes" field in the mutation.
func (m *SettingsMutation) AgentReportFrequenceInMinutes() (r int, exists bool) {
	v := m.agent_report_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentReportFrequenceInMinutes returns the old "agent_report_frequence_in_minutes" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldAgentReportFrequenceInMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentReportFrequenceInMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentReportFrequenceInMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentReportFrequenceInMinutes: %w", err)
	}
	return oldValue.AgentReportFrequenceInMinutes, nil
}

// AddAgentReportFrequenceInMinutes adds i to the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) AddAgentReportFrequenceInMinutes(i int) {
	if m.addagent_report_frequence_in_minutes != nil {
		*m.addagent_report_frequence_in_minutes += i
	} else {
		m.addagent_report_frequence_in_minutes = &i
	}
}

// AddedAgentReportFrequenceInMinutes returns the value that was added to the "agent_report_frequence_in_minutes" field in this mutation.
func (m *SettingsMutation) AddedAgentReportFrequenceInMinutes() (r int, exists bool) {
	v := m.addagent_report_frequence_in_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearAgentReportFrequenceInMinutes clears the value of the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) ClearAgentReportFrequenceInMinutes() {
	m.agent_report_frequence_in_minutes = nil
	m.addagent_report_frequence_in_minutes = nil
	m.clearedFields[settings.FieldAgentReportFrequenceInMinutes] = struct{}{}
}

// AgentReportFrequenceInMinutesCleared returns if the "agent_report_frequence_in_minutes" field was cleared in this mutation.
func (m *SettingsMutation) AgentReportFrequenceInMinutesCleared() bool {
	_, ok := m.clearedFields[settings.FieldAgentReportFrequenceInMinutes]
	return ok
}

// ResetAgentReportFrequenceInMinutes resets all changes to the "agent_report_frequence_in_minutes" field.
func (m *SettingsMutation) ResetAgentReportFrequenceInMinutes() {
	m.agent_report_frequence_in_minutes = nil
	m.addagent_report_frequence_in_minutes = nil
	delete(m.clearedFields, settings.FieldAgentReportFrequenceInMinutes)
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.language != nil {
		fields = append(fields, settings.FieldLanguage)
	}
	if m.organization != nil {
		fields = append(fields, settings.FieldOrganization)
	}
	if m.postal_address != nil {
		fields = append(fields, settings.FieldPostalAddress)
	}
	if m.postal_code != nil {
		fields = append(fields, settings.FieldPostalCode)
	}
	if m.locality != nil {
		fields = append(fields, settings.FieldLocality)
	}
	if m.province != nil {
		fields = append(fields, settings.FieldProvince)
	}
	if m.state != nil {
		fields = append(fields, settings.FieldState)
	}
	if m.country != nil {
		fields = append(fields, settings.FieldCountry)
	}
	if m.smtp_server != nil {
		fields = append(fields, settings.FieldSMTPServer)
	}
	if m.smtp_port != nil {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.smtp_user != nil {
		fields = append(fields, settings.FieldSMTPUser)
	}
	if m.smtp_password != nil {
		fields = append(fields, settings.FieldSMTPPassword)
	}
	if m.smtp_auth != nil {
		fields = append(fields, settings.FieldSMTPAuth)
	}
	if m.smtp_tls != nil {
		fields = append(fields, settings.FieldSMTPTLS)
	}
	if m.smtp_starttls != nil {
		fields = append(fields, settings.FieldSMTPStarttls)
	}
	if m.nats_server != nil {
		fields = append(fields, settings.FieldNatsServer)
	}
	if m.nats_port != nil {
		fields = append(fields, settings.FieldNatsPort)
	}
	if m.message_from != nil {
		fields = append(fields, settings.FieldMessageFrom)
	}
	if m.max_upload_size != nil {
		fields = append(fields, settings.FieldMaxUploadSize)
	}
	if m.user_cert_years_valid != nil {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.nats_request_timeout_seconds != nil {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.refresh_time_in_minutes != nil {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.session_lifetime_in_minutes != nil {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.update_channel != nil {
		fields = append(fields, settings.FieldUpdateChannel)
	}
	if m.created != nil {
		fields = append(fields, settings.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, settings.FieldModified)
	}
	if m.agent_report_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldLanguage:
		return m.Language()
	case settings.FieldOrganization:
		return m.Organization()
	case settings.FieldPostalAddress:
		return m.PostalAddress()
	case settings.FieldPostalCode:
		return m.PostalCode()
	case settings.FieldLocality:
		return m.Locality()
	case settings.FieldProvince:
		return m.Province()
	case settings.FieldState:
		return m.State()
	case settings.FieldCountry:
		return m.Country()
	case settings.FieldSMTPServer:
		return m.SMTPServer()
	case settings.FieldSMTPPort:
		return m.SMTPPort()
	case settings.FieldSMTPUser:
		return m.SMTPUser()
	case settings.FieldSMTPPassword:
		return m.SMTPPassword()
	case settings.FieldSMTPAuth:
		return m.SMTPAuth()
	case settings.FieldSMTPTLS:
		return m.SMTPTLS()
	case settings.FieldSMTPStarttls:
		return m.SMTPStarttls()
	case settings.FieldNatsServer:
		return m.NatsServer()
	case settings.FieldNatsPort:
		return m.NatsPort()
	case settings.FieldMessageFrom:
		return m.MessageFrom()
	case settings.FieldMaxUploadSize:
		return m.MaxUploadSize()
	case settings.FieldUserCertYearsValid:
		return m.UserCertYearsValid()
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.NatsRequestTimeoutSeconds()
	case settings.FieldRefreshTimeInMinutes:
		return m.RefreshTimeInMinutes()
	case settings.FieldSessionLifetimeInMinutes:
		return m.SessionLifetimeInMinutes()
	case settings.FieldUpdateChannel:
		return m.UpdateChannel()
	case settings.FieldCreated:
		return m.Created()
	case settings.FieldModified:
		return m.Modified()
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.AgentReportFrequenceInMinutes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldLanguage:
		return m.OldLanguage(ctx)
	case settings.FieldOrganization:
		return m.OldOrganization(ctx)
	case settings.FieldPostalAddress:
		return m.OldPostalAddress(ctx)
	case settings.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case settings.FieldLocality:
		return m.OldLocality(ctx)
	case settings.FieldProvince:
		return m.OldProvince(ctx)
	case settings.FieldState:
		return m.OldState(ctx)
	case settings.FieldCountry:
		return m.OldCountry(ctx)
	case settings.FieldSMTPServer:
		return m.OldSMTPServer(ctx)
	case settings.FieldSMTPPort:
		return m.OldSMTPPort(ctx)
	case settings.FieldSMTPUser:
		return m.OldSMTPUser(ctx)
	case settings.FieldSMTPPassword:
		return m.OldSMTPPassword(ctx)
	case settings.FieldSMTPAuth:
		return m.OldSMTPAuth(ctx)
	case settings.FieldSMTPTLS:
		return m.OldSMTPTLS(ctx)
	case settings.FieldSMTPStarttls:
		return m.OldSMTPStarttls(ctx)
	case settings.FieldNatsServer:
		return m.OldNatsServer(ctx)
	case settings.FieldNatsPort:
		return m.OldNatsPort(ctx)
	case settings.FieldMessageFrom:
		return m.OldMessageFrom(ctx)
	case settings.FieldMaxUploadSize:
		return m.OldMaxUploadSize(ctx)
	case settings.FieldUserCertYearsValid:
		return m.OldUserCertYearsValid(ctx)
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.OldNatsRequestTimeoutSeconds(ctx)
	case settings.FieldRefreshTimeInMinutes:
		return m.OldRefreshTimeInMinutes(ctx)
	case settings.FieldSessionLifetimeInMinutes:
		return m.OldSessionLifetimeInMinutes(ctx)
	case settings.FieldUpdateChannel:
		return m.OldUpdateChannel(ctx)
	case settings.FieldCreated:
		return m.OldCreated(ctx)
	case settings.FieldModified:
		return m.OldModified(ctx)
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.OldAgentReportFrequenceInMinutes(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case settings.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case settings.FieldPostalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalAddress(v)
		return nil
	case settings.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case settings.FieldLocality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocality(v)
		return nil
	case settings.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case settings.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case settings.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case settings.FieldSMTPServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPServer(v)
		return nil
	case settings.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPort(v)
		return nil
	case settings.FieldSMTPUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPUser(v)
		return nil
	case settings.FieldSMTPPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPPassword(v)
		return nil
	case settings.FieldSMTPAuth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPAuth(v)
		return nil
	case settings.FieldSMTPTLS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPTLS(v)
		return nil
	case settings.FieldSMTPStarttls:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSMTPStarttls(v)
		return nil
	case settings.FieldNatsServer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsServer(v)
		return nil
	case settings.FieldNatsPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsPort(v)
		return nil
	case settings.FieldMessageFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageFrom(v)
		return nil
	case settings.FieldMaxUploadSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUploadSize(v)
		return nil
	case settings.FieldUserCertYearsValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCertYearsValid(v)
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNatsRequestTimeoutSeconds(v)
		return nil
	case settings.FieldRefreshTimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTimeInMinutes(v)
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionLifetimeInMinutes(v)
		return nil
	case settings.FieldUpdateChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateChannel(v)
		return nil
	case settings.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case settings.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentReportFrequenceInMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.addsmtp_port != nil {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.adduser_cert_years_valid != nil {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.addnats_request_timeout_seconds != nil {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.addrefresh_time_in_minutes != nil {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.addsession_lifetime_in_minutes != nil {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.addagent_report_frequence_in_minutes != nil {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldSMTPPort:
		return m.AddedSMTPPort()
	case settings.FieldUserCertYearsValid:
		return m.AddedUserCertYearsValid()
	case settings.FieldNatsRequestTimeoutSeconds:
		return m.AddedNatsRequestTimeoutSeconds()
	case settings.FieldRefreshTimeInMinutes:
		return m.AddedRefreshTimeInMinutes()
	case settings.FieldSessionLifetimeInMinutes:
		return m.AddedSessionLifetimeInMinutes()
	case settings.FieldAgentReportFrequenceInMinutes:
		return m.AddedAgentReportFrequenceInMinutes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldSMTPPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSMTPPort(v)
		return nil
	case settings.FieldUserCertYearsValid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserCertYearsValid(v)
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNatsRequestTimeoutSeconds(v)
		return nil
	case settings.FieldRefreshTimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTimeInMinutes(v)
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionLifetimeInMinutes(v)
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentReportFrequenceInMinutes(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(settings.FieldLanguage) {
		fields = append(fields, settings.FieldLanguage)
	}
	if m.FieldCleared(settings.FieldOrganization) {
		fields = append(fields, settings.FieldOrganization)
	}
	if m.FieldCleared(settings.FieldPostalAddress) {
		fields = append(fields, settings.FieldPostalAddress)
	}
	if m.FieldCleared(settings.FieldPostalCode) {
		fields = append(fields, settings.FieldPostalCode)
	}
	if m.FieldCleared(settings.FieldLocality) {
		fields = append(fields, settings.FieldLocality)
	}
	if m.FieldCleared(settings.FieldProvince) {
		fields = append(fields, settings.FieldProvince)
	}
	if m.FieldCleared(settings.FieldState) {
		fields = append(fields, settings.FieldState)
	}
	if m.FieldCleared(settings.FieldCountry) {
		fields = append(fields, settings.FieldCountry)
	}
	if m.FieldCleared(settings.FieldSMTPServer) {
		fields = append(fields, settings.FieldSMTPServer)
	}
	if m.FieldCleared(settings.FieldSMTPPort) {
		fields = append(fields, settings.FieldSMTPPort)
	}
	if m.FieldCleared(settings.FieldSMTPUser) {
		fields = append(fields, settings.FieldSMTPUser)
	}
	if m.FieldCleared(settings.FieldSMTPPassword) {
		fields = append(fields, settings.FieldSMTPPassword)
	}
	if m.FieldCleared(settings.FieldSMTPAuth) {
		fields = append(fields, settings.FieldSMTPAuth)
	}
	if m.FieldCleared(settings.FieldSMTPTLS) {
		fields = append(fields, settings.FieldSMTPTLS)
	}
	if m.FieldCleared(settings.FieldSMTPStarttls) {
		fields = append(fields, settings.FieldSMTPStarttls)
	}
	if m.FieldCleared(settings.FieldNatsServer) {
		fields = append(fields, settings.FieldNatsServer)
	}
	if m.FieldCleared(settings.FieldNatsPort) {
		fields = append(fields, settings.FieldNatsPort)
	}
	if m.FieldCleared(settings.FieldMessageFrom) {
		fields = append(fields, settings.FieldMessageFrom)
	}
	if m.FieldCleared(settings.FieldMaxUploadSize) {
		fields = append(fields, settings.FieldMaxUploadSize)
	}
	if m.FieldCleared(settings.FieldUserCertYearsValid) {
		fields = append(fields, settings.FieldUserCertYearsValid)
	}
	if m.FieldCleared(settings.FieldNatsRequestTimeoutSeconds) {
		fields = append(fields, settings.FieldNatsRequestTimeoutSeconds)
	}
	if m.FieldCleared(settings.FieldRefreshTimeInMinutes) {
		fields = append(fields, settings.FieldRefreshTimeInMinutes)
	}
	if m.FieldCleared(settings.FieldSessionLifetimeInMinutes) {
		fields = append(fields, settings.FieldSessionLifetimeInMinutes)
	}
	if m.FieldCleared(settings.FieldUpdateChannel) {
		fields = append(fields, settings.FieldUpdateChannel)
	}
	if m.FieldCleared(settings.FieldCreated) {
		fields = append(fields, settings.FieldCreated)
	}
	if m.FieldCleared(settings.FieldModified) {
		fields = append(fields, settings.FieldModified)
	}
	if m.FieldCleared(settings.FieldAgentReportFrequenceInMinutes) {
		fields = append(fields, settings.FieldAgentReportFrequenceInMinutes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	switch name {
	case settings.FieldLanguage:
		m.ClearLanguage()
		return nil
	case settings.FieldOrganization:
		m.ClearOrganization()
		return nil
	case settings.FieldPostalAddress:
		m.ClearPostalAddress()
		return nil
	case settings.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case settings.FieldLocality:
		m.ClearLocality()
		return nil
	case settings.FieldProvince:
		m.ClearProvince()
		return nil
	case settings.FieldState:
		m.ClearState()
		return nil
	case settings.FieldCountry:
		m.ClearCountry()
		return nil
	case settings.FieldSMTPServer:
		m.ClearSMTPServer()
		return nil
	case settings.FieldSMTPPort:
		m.ClearSMTPPort()
		return nil
	case settings.FieldSMTPUser:
		m.ClearSMTPUser()
		return nil
	case settings.FieldSMTPPassword:
		m.ClearSMTPPassword()
		return nil
	case settings.FieldSMTPAuth:
		m.ClearSMTPAuth()
		return nil
	case settings.FieldSMTPTLS:
		m.ClearSMTPTLS()
		return nil
	case settings.FieldSMTPStarttls:
		m.ClearSMTPStarttls()
		return nil
	case settings.FieldNatsServer:
		m.ClearNatsServer()
		return nil
	case settings.FieldNatsPort:
		m.ClearNatsPort()
		return nil
	case settings.FieldMessageFrom:
		m.ClearMessageFrom()
		return nil
	case settings.FieldMaxUploadSize:
		m.ClearMaxUploadSize()
		return nil
	case settings.FieldUserCertYearsValid:
		m.ClearUserCertYearsValid()
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		m.ClearNatsRequestTimeoutSeconds()
		return nil
	case settings.FieldRefreshTimeInMinutes:
		m.ClearRefreshTimeInMinutes()
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		m.ClearSessionLifetimeInMinutes()
		return nil
	case settings.FieldUpdateChannel:
		m.ClearUpdateChannel()
		return nil
	case settings.FieldCreated:
		m.ClearCreated()
		return nil
	case settings.FieldModified:
		m.ClearModified()
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		m.ClearAgentReportFrequenceInMinutes()
		return nil
	}
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldLanguage:
		m.ResetLanguage()
		return nil
	case settings.FieldOrganization:
		m.ResetOrganization()
		return nil
	case settings.FieldPostalAddress:
		m.ResetPostalAddress()
		return nil
	case settings.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case settings.FieldLocality:
		m.ResetLocality()
		return nil
	case settings.FieldProvince:
		m.ResetProvince()
		return nil
	case settings.FieldState:
		m.ResetState()
		return nil
	case settings.FieldCountry:
		m.ResetCountry()
		return nil
	case settings.FieldSMTPServer:
		m.ResetSMTPServer()
		return nil
	case settings.FieldSMTPPort:
		m.ResetSMTPPort()
		return nil
	case settings.FieldSMTPUser:
		m.ResetSMTPUser()
		return nil
	case settings.FieldSMTPPassword:
		m.ResetSMTPPassword()
		return nil
	case settings.FieldSMTPAuth:
		m.ResetSMTPAuth()
		return nil
	case settings.FieldSMTPTLS:
		m.ResetSMTPTLS()
		return nil
	case settings.FieldSMTPStarttls:
		m.ResetSMTPStarttls()
		return nil
	case settings.FieldNatsServer:
		m.ResetNatsServer()
		return nil
	case settings.FieldNatsPort:
		m.ResetNatsPort()
		return nil
	case settings.FieldMessageFrom:
		m.ResetMessageFrom()
		return nil
	case settings.FieldMaxUploadSize:
		m.ResetMaxUploadSize()
		return nil
	case settings.FieldUserCertYearsValid:
		m.ResetUserCertYearsValid()
		return nil
	case settings.FieldNatsRequestTimeoutSeconds:
		m.ResetNatsRequestTimeoutSeconds()
		return nil
	case settings.FieldRefreshTimeInMinutes:
		m.ResetRefreshTimeInMinutes()
		return nil
	case settings.FieldSessionLifetimeInMinutes:
		m.ResetSessionLifetimeInMinutes()
		return nil
	case settings.FieldUpdateChannel:
		m.ResetUpdateChannel()
		return nil
	case settings.FieldCreated:
		m.ResetCreated()
		return nil
	case settings.FieldModified:
		m.ResetModified()
		return nil
	case settings.FieldAgentReportFrequenceInMinutes:
		m.ResetAgentReportFrequenceInMinutes()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// ShareMutation represents an operation that mutates the Share nodes in the graph.
type ShareMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	_path         *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Share, error)
	predicates    []predicate.Share
}

var _ ent.Mutation = (*ShareMutation)(nil)

// shareOption allows management of the mutation configuration using functional options.
type shareOption func(*ShareMutation)

// newShareMutation creates new mutation for the Share entity.
func newShareMutation(c config, op Op, opts ...shareOption) *ShareMutation {
	m := &ShareMutation{
		config:        c,
		op:            op,
		typ:           TypeShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShareID sets the ID field of the mutation.
func withShareID(id int) shareOption {
	return func(m *ShareMutation) {
		var (
			err   error
			once  sync.Once
			value *Share
		)
		m.oldValue = func(ctx context.Context) (*Share, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Share.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShare sets the old Share of the mutation.
func withShare(node *Share) shareOption {
	return func(m *ShareMutation) {
		m.oldValue = func(context.Context) (*Share, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Share.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ShareMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShareMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShareMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ShareMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShareMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ShareMutation) ResetDescription() {
	m.description = nil
}

// SetPath sets the "path" field.
func (m *ShareMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ShareMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ShareMutation) ClearPath() {
	m._path = nil
	m.clearedFields[share.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ShareMutation) PathCleared() bool {
	_, ok := m.clearedFields[share.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ShareMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, share.FieldPath)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *ShareMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *ShareMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *ShareMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ShareMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ShareMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ShareMutation builder.
func (m *ShareMutation) Where(ps ...predicate.Share) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Share, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Share).
func (m *ShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShareMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, share.FieldName)
	}
	if m.description != nil {
		fields = append(fields, share.FieldDescription)
	}
	if m._path != nil {
		fields = append(fields, share.FieldPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case share.FieldName:
		return m.Name()
	case share.FieldDescription:
		return m.Description()
	case share.FieldPath:
		return m.Path()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case share.FieldName:
		return m.OldName(ctx)
	case share.FieldDescription:
		return m.OldDescription(ctx)
	case share.FieldPath:
		return m.OldPath(ctx)
	}
	return nil, fmt.Errorf("unknown Share field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case share.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case share.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case share.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Share numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShareMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(share.FieldPath) {
		fields = append(fields, share.FieldPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShareMutation) ClearField(name string) error {
	switch name {
	case share.FieldPath:
		m.ClearPath()
		return nil
	}
	return fmt.Errorf("unknown Share nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShareMutation) ResetField(name string) error {
	switch name {
	case share.FieldName:
		m.ResetName()
		return nil
	case share.FieldDescription:
		m.ResetDescription()
		return nil
	case share.FieldPath:
		m.ResetPath()
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, share.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case share.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, share.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShareMutation) EdgeCleared(name string) bool {
	switch name {
	case share.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShareMutation) ClearEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Share unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShareMutation) ResetEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Share edge %s", name)
}

// SystemUpdateMutation represents an operation that mutates the SystemUpdate nodes in the graph.
type SystemUpdateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	status          *string
	last_install    *time.Time
	last_search     *time.Time
	pending_updates *bool
	clearedFields   map[string]struct{}
	owner           *string
	clearedowner    bool
	done            bool
	oldValue        func(context.Context) (*SystemUpdate, error)
	predicates      []predicate.SystemUpdate
}

var _ ent.Mutation = (*SystemUpdateMutation)(nil)

// systemupdateOption allows management of the mutation configuration using functional options.
type systemupdateOption func(*SystemUpdateMutation)

// newSystemUpdateMutation creates new mutation for the SystemUpdate entity.
func newSystemUpdateMutation(c config, op Op, opts ...systemupdateOption) *SystemUpdateMutation {
	m := &SystemUpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemUpdateID sets the ID field of the mutation.
func withSystemUpdateID(id int) systemupdateOption {
	return func(m *SystemUpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemUpdate
		)
		m.oldValue = func(ctx context.Context) (*SystemUpdate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemUpdate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemUpdate sets the old SystemUpdate of the mutation.
func withSystemUpdate(node *SystemUpdate) systemupdateOption {
	return func(m *SystemUpdateMutation) {
		m.oldValue = func(context.Context) (*SystemUpdate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemUpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemUpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemUpdateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemUpdateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemUpdate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *SystemUpdateMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemUpdateMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemUpdateMutation) ResetStatus() {
	m.status = nil
}

// SetLastInstall sets the "last_install" field.
func (m *SystemUpdateMutation) SetLastInstall(t time.Time) {
	m.last_install = &t
}

// LastInstall returns the value of the "last_install" field in the mutation.
func (m *SystemUpdateMutation) LastInstall() (r time.Time, exists bool) {
	v := m.last_install
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInstall returns the old "last_install" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldLastInstall(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInstall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInstall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInstall: %w", err)
	}
	return oldValue.LastInstall, nil
}

// ResetLastInstall resets all changes to the "last_install" field.
func (m *SystemUpdateMutation) ResetLastInstall() {
	m.last_install = nil
}

// SetLastSearch sets the "last_search" field.
func (m *SystemUpdateMutation) SetLastSearch(t time.Time) {
	m.last_search = &t
}

// LastSearch returns the value of the "last_search" field in the mutation.
func (m *SystemUpdateMutation) LastSearch() (r time.Time, exists bool) {
	v := m.last_search
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSearch returns the old "last_search" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldLastSearch(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSearch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSearch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSearch: %w", err)
	}
	return oldValue.LastSearch, nil
}

// ResetLastSearch resets all changes to the "last_search" field.
func (m *SystemUpdateMutation) ResetLastSearch() {
	m.last_search = nil
}

// SetPendingUpdates sets the "pending_updates" field.
func (m *SystemUpdateMutation) SetPendingUpdates(b bool) {
	m.pending_updates = &b
}

// PendingUpdates returns the value of the "pending_updates" field in the mutation.
func (m *SystemUpdateMutation) PendingUpdates() (r bool, exists bool) {
	v := m.pending_updates
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingUpdates returns the old "pending_updates" field's value of the SystemUpdate entity.
// If the SystemUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemUpdateMutation) OldPendingUpdates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingUpdates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingUpdates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingUpdates: %w", err)
	}
	return oldValue.PendingUpdates, nil
}

// ResetPendingUpdates resets all changes to the "pending_updates" field.
func (m *SystemUpdateMutation) ResetPendingUpdates() {
	m.pending_updates = nil
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *SystemUpdateMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *SystemUpdateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *SystemUpdateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SystemUpdateMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SystemUpdateMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SystemUpdateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SystemUpdateMutation builder.
func (m *SystemUpdateMutation) Where(ps ...predicate.SystemUpdate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemUpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemUpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemUpdate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemUpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemUpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemUpdate).
func (m *SystemUpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemUpdateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, systemupdate.FieldStatus)
	}
	if m.last_install != nil {
		fields = append(fields, systemupdate.FieldLastInstall)
	}
	if m.last_search != nil {
		fields = append(fields, systemupdate.FieldLastSearch)
	}
	if m.pending_updates != nil {
		fields = append(fields, systemupdate.FieldPendingUpdates)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemUpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemupdate.FieldStatus:
		return m.Status()
	case systemupdate.FieldLastInstall:
		return m.LastInstall()
	case systemupdate.FieldLastSearch:
		return m.LastSearch()
	case systemupdate.FieldPendingUpdates:
		return m.PendingUpdates()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemUpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemupdate.FieldStatus:
		return m.OldStatus(ctx)
	case systemupdate.FieldLastInstall:
		return m.OldLastInstall(ctx)
	case systemupdate.FieldLastSearch:
		return m.OldLastSearch(ctx)
	case systemupdate.FieldPendingUpdates:
		return m.OldPendingUpdates(ctx)
	}
	return nil, fmt.Errorf("unknown SystemUpdate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemUpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemupdate.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemupdate.FieldLastInstall:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInstall(v)
		return nil
	case systemupdate.FieldLastSearch:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSearch(v)
		return nil
	case systemupdate.FieldPendingUpdates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingUpdates(v)
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemUpdateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemUpdateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemUpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemUpdate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemUpdateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemUpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemUpdateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SystemUpdate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemUpdateMutation) ResetField(name string) error {
	switch name {
	case systemupdate.FieldStatus:
		m.ResetStatus()
		return nil
	case systemupdate.FieldLastInstall:
		m.ResetLastInstall()
		return nil
	case systemupdate.FieldLastSearch:
		m.ResetLastSearch()
		return nil
	case systemupdate.FieldPendingUpdates:
		m.ResetPendingUpdates()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemUpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, systemupdate.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemUpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemupdate.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemUpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemUpdateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemUpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, systemupdate.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemUpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case systemupdate.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemUpdateMutation) ClearEdge(name string) error {
	switch name {
	case systemupdate.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemUpdateMutation) ResetEdge(name string) error {
	switch name {
	case systemupdate.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown SystemUpdate edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *int
	tag             *string
	description     *string
	color           *string
	clearedFields   map[string]struct{}
	owner           map[string]struct{}
	removedowner    map[string]struct{}
	clearedowner    bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTag sets the "tag" field.
func (m *TagMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *TagMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *TagMutation) ResetTag() {
	m.tag = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
}

// AddOwnerIDs adds the "owner" edge to the Agent entity by ids.
func (m *TagMutation) AddOwnerIDs(ids ...string) {
	if m.owner == nil {
		m.owner = make(map[string]struct{})
	}
	for i := range ids {
		m.owner[ids[i]] = struct{}{}
	}
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *TagMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *TagMutation) OwnerCleared() bool {
	return m.clearedowner
}

// RemoveOwnerIDs removes the "owner" edge to the Agent entity by IDs.
func (m *TagMutation) RemoveOwnerIDs(ids ...string) {
	if m.removedowner == nil {
		m.removedowner = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.owner, ids[i])
		m.removedowner[ids[i]] = struct{}{}
	}
}

// RemovedOwner returns the removed IDs of the "owner" edge to the Agent entity.
func (m *TagMutation) RemovedOwnerIDs() (ids []string) {
	for id := range m.removedowner {
		ids = append(ids, id)
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
func (m *TagMutation) OwnerIDs() (ids []string) {
	for id := range m.owner {
		ids = append(ids, id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TagMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
	m.removedowner = nil
}

// SetParentID sets the "parent" edge to the Tag entity by id.
func (m *TagMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Tag entity.
func (m *TagMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Tag entity was cleared.
func (m *TagMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TagMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TagMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TagMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Tag entity by ids.
func (m *TagMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Tag entity.
func (m *TagMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Tag entity was cleared.
func (m *TagMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Tag entity by IDs.
func (m *TagMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Tag entity.
func (m *TagMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TagMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TagMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tag != nil {
		fields = append(fields, tag.FieldTag)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTag:
		return m.Tag()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldTag:
		return m.OldTag(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldTag:
		m.ResetTag()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, tag.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.owner))
		for id := range m.owner {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedowner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.removedchildren != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		ids := make([]ent.Value, 0, len(m.removedowner))
		for id := range m.removedowner {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, tag.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, tag.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, tag.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeOwner:
		return m.clearedowner
	case tag.EdgeParent:
		return m.clearedparent
	case tag.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ResetOwner()
		return nil
	case tag.EdgeParent:
		m.ResetParent()
		return nil
	case tag.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UpdateMutation represents an operation that mutates the Update nodes in the graph.
type UpdateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	date          *time.Time
	support_url   *string
	clearedFields map[string]struct{}
	owner         *string
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Update, error)
	predicates    []predicate.Update
}

var _ ent.Mutation = (*UpdateMutation)(nil)

// updateOption allows management of the mutation configuration using functional options.
type updateOption func(*UpdateMutation)

// newUpdateMutation creates new mutation for the Update entity.
func newUpdateMutation(c config, op Op, opts ...updateOption) *UpdateMutation {
	m := &UpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpdateID sets the ID field of the mutation.
func withUpdateID(id int) updateOption {
	return func(m *UpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *Update
		)
		m.oldValue = func(ctx context.Context) (*Update, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Update.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpdate sets the old Update of the mutation.
func withUpdate(node *Update) updateOption {
	return func(m *UpdateMutation) {
		m.oldValue = func(context.Context) (*Update, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpdateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpdateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Update.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *UpdateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UpdateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UpdateMutation) ResetTitle() {
	m.title = nil
}

// SetDate sets the "date" field.
func (m *UpdateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *UpdateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *UpdateMutation) ResetDate() {
	m.date = nil
}

// SetSupportURL sets the "support_url" field.
func (m *UpdateMutation) SetSupportURL(s string) {
	m.support_url = &s
}

// SupportURL returns the value of the "support_url" field in the mutation.
func (m *UpdateMutation) SupportURL() (r string, exists bool) {
	v := m.support_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportURL returns the old "support_url" field's value of the Update entity.
// If the Update object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpdateMutation) OldSupportURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportURL: %w", err)
	}
	return oldValue.SupportURL, nil
}

// ClearSupportURL clears the value of the "support_url" field.
func (m *UpdateMutation) ClearSupportURL() {
	m.support_url = nil
	m.clearedFields[update.FieldSupportURL] = struct{}{}
}

// SupportURLCleared returns if the "support_url" field was cleared in this mutation.
func (m *UpdateMutation) SupportURLCleared() bool {
	_, ok := m.clearedFields[update.FieldSupportURL]
	return ok
}

// ResetSupportURL resets all changes to the "support_url" field.
func (m *UpdateMutation) ResetSupportURL() {
	m.support_url = nil
	delete(m.clearedFields, update.FieldSupportURL)
}

// SetOwnerID sets the "owner" edge to the Agent entity by id.
func (m *UpdateMutation) SetOwnerID(id string) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Agent entity.
func (m *UpdateMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Agent entity was cleared.
func (m *UpdateMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UpdateMutation) OwnerID() (id string, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UpdateMutation) OwnerIDs() (ids []string) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UpdateMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UpdateMutation builder.
func (m *UpdateMutation) Where(ps ...predicate.Update) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Update, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Update).
func (m *UpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpdateMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, update.FieldTitle)
	}
	if m.date != nil {
		fields = append(fields, update.FieldDate)
	}
	if m.support_url != nil {
		fields = append(fields, update.FieldSupportURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case update.FieldTitle:
		return m.Title()
	case update.FieldDate:
		return m.Date()
	case update.FieldSupportURL:
		return m.SupportURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case update.FieldTitle:
		return m.OldTitle(ctx)
	case update.FieldDate:
		return m.OldDate(ctx)
	case update.FieldSupportURL:
		return m.OldSupportURL(ctx)
	}
	return nil, fmt.Errorf("unknown Update field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case update.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case update.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case update.FieldSupportURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportURL(v)
		return nil
	}
	return fmt.Errorf("unknown Update field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpdateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpdateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Update numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpdateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(update.FieldSupportURL) {
		fields = append(fields, update.FieldSupportURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpdateMutation) ClearField(name string) error {
	switch name {
	case update.FieldSupportURL:
		m.ClearSupportURL()
		return nil
	}
	return fmt.Errorf("unknown Update nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpdateMutation) ResetField(name string) error {
	switch name {
	case update.FieldTitle:
		m.ResetTitle()
		return nil
	case update.FieldDate:
		m.ResetDate()
		return nil
	case update.FieldSupportURL:
		m.ResetSupportURL()
		return nil
	}
	return fmt.Errorf("unknown Update field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, update.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case update.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpdateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, update.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case update.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpdateMutation) ClearEdge(name string) error {
	switch name {
	case update.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Update unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpdateMutation) ResetEdge(name string) error {
	switch name {
	case update.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Update edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	email               *string
	phone               *string
	country             *string
	email_verified      *bool
	register            *string
	cert_clear_password *string
	expiry              *time.Time
	created             *time.Time
	modified            *time.Time
	clearedFields       map[string]struct{}
	sessions            map[string]struct{}
	removedsessions     map[string]struct{}
	clearedsessions     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("openuem_ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetCountry sets the "country" field.
func (m *UserMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *UserMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[user.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *UserMutation) CountryCleared() bool {
	_, ok := m.clearedFields[user.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *UserMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, user.FieldCountry)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetRegister sets the "register" field.
func (m *UserMutation) SetRegister(s string) {
	m.register = &s
}

// Register returns the value of the "register" field in the mutation.
func (m *UserMutation) Register() (r string, exists bool) {
	v := m.register
	if v == nil {
		return
	}
	return *v, true
}

// OldRegister returns the old "register" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegister(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegister is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegister requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegister: %w", err)
	}
	return oldValue.Register, nil
}

// ResetRegister resets all changes to the "register" field.
func (m *UserMutation) ResetRegister() {
	m.register = nil
}

// SetCertClearPassword sets the "cert_clear_password" field.
func (m *UserMutation) SetCertClearPassword(s string) {
	m.cert_clear_password = &s
}

// CertClearPassword returns the value of the "cert_clear_password" field in the mutation.
func (m *UserMutation) CertClearPassword() (r string, exists bool) {
	v := m.cert_clear_password
	if v == nil {
		return
	}
	return *v, true
}

// OldCertClearPassword returns the old "cert_clear_password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCertClearPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertClearPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertClearPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertClearPassword: %w", err)
	}
	return oldValue.CertClearPassword, nil
}

// ClearCertClearPassword clears the value of the "cert_clear_password" field.
func (m *UserMutation) ClearCertClearPassword() {
	m.cert_clear_password = nil
	m.clearedFields[user.FieldCertClearPassword] = struct{}{}
}

// CertClearPasswordCleared returns if the "cert_clear_password" field was cleared in this mutation.
func (m *UserMutation) CertClearPasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldCertClearPassword]
	return ok
}

// ResetCertClearPassword resets all changes to the "cert_clear_password" field.
func (m *UserMutation) ResetCertClearPassword() {
	m.cert_clear_password = nil
	delete(m.clearedFields, user.FieldCertClearPassword)
}

// SetExpiry sets the "expiry" field.
func (m *UserMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *UserMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ClearExpiry clears the value of the "expiry" field.
func (m *UserMutation) ClearExpiry() {
	m.expiry = nil
	m.clearedFields[user.FieldExpiry] = struct{}{}
}

// ExpiryCleared returns if the "expiry" field was cleared in this mutation.
func (m *UserMutation) ExpiryCleared() bool {
	_, ok := m.clearedFields[user.FieldExpiry]
	return ok
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *UserMutation) ResetExpiry() {
	m.expiry = nil
	delete(m.clearedFields, user.FieldExpiry)
}

// SetCreated sets the "created" field.
func (m *UserMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *UserMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ClearCreated clears the value of the "created" field.
func (m *UserMutation) ClearCreated() {
	m.created = nil
	m.clearedFields[user.FieldCreated] = struct{}{}
}

// CreatedCleared returns if the "created" field was cleared in this mutation.
func (m *UserMutation) CreatedCleared() bool {
	_, ok := m.clearedFields[user.FieldCreated]
	return ok
}

// ResetCreated resets all changes to the "created" field.
func (m *UserMutation) ResetCreated() {
	m.created = nil
	delete(m.clearedFields, user.FieldCreated)
}

// SetModified sets the "modified" field.
func (m *UserMutation) SetModified(t time.Time) {
	m.modified = &t
}

// Modified returns the value of the "modified" field in the mutation.
func (m *UserMutation) Modified() (r time.Time, exists bool) {
	v := m.modified
	if v == nil {
		return
	}
	return *v, true
}

// OldModified returns the old "modified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldModified(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModified: %w", err)
	}
	return oldValue.Modified, nil
}

// ClearModified clears the value of the "modified" field.
func (m *UserMutation) ClearModified() {
	m.modified = nil
	m.clearedFields[user.FieldModified] = struct{}{}
}

// ModifiedCleared returns if the "modified" field was cleared in this mutation.
func (m *UserMutation) ModifiedCleared() bool {
	_, ok := m.clearedFields[user.FieldModified]
	return ok
}

// ResetModified resets all changes to the "modified" field.
func (m *UserMutation) ResetModified() {
	m.modified = nil
	delete(m.clearedFields, user.FieldModified)
}

// AddSessionIDs adds the "sessions" edge to the Sessions entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Sessions entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Sessions entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Sessions entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Sessions entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.country != nil {
		fields = append(fields, user.FieldCountry)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.register != nil {
		fields = append(fields, user.FieldRegister)
	}
	if m.cert_clear_password != nil {
		fields = append(fields, user.FieldCertClearPassword)
	}
	if m.expiry != nil {
		fields = append(fields, user.FieldExpiry)
	}
	if m.created != nil {
		fields = append(fields, user.FieldCreated)
	}
	if m.modified != nil {
		fields = append(fields, user.FieldModified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldCountry:
		return m.Country()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldRegister:
		return m.Register()
	case user.FieldCertClearPassword:
		return m.CertClearPassword()
	case user.FieldExpiry:
		return m.Expiry()
	case user.FieldCreated:
		return m.Created()
	case user.FieldModified:
		return m.Modified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldCountry:
		return m.OldCountry(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldRegister:
		return m.OldRegister(ctx)
	case user.FieldCertClearPassword:
		return m.OldCertClearPassword(ctx)
	case user.FieldExpiry:
		return m.OldExpiry(ctx)
	case user.FieldCreated:
		return m.OldCreated(ctx)
	case user.FieldModified:
		return m.OldModified(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldRegister:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegister(v)
		return nil
	case user.FieldCertClearPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertClearPassword(v)
		return nil
	case user.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	case user.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case user.FieldModified:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModified(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldCountry) {
		fields = append(fields, user.FieldCountry)
	}
	if m.FieldCleared(user.FieldCertClearPassword) {
		fields = append(fields, user.FieldCertClearPassword)
	}
	if m.FieldCleared(user.FieldExpiry) {
		fields = append(fields, user.FieldExpiry)
	}
	if m.FieldCleared(user.FieldCreated) {
		fields = append(fields, user.FieldCreated)
	}
	if m.FieldCleared(user.FieldModified) {
		fields = append(fields, user.FieldModified)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldCountry:
		m.ClearCountry()
		return nil
	case user.FieldCertClearPassword:
		m.ClearCertClearPassword()
		return nil
	case user.FieldExpiry:
		m.ClearExpiry()
		return nil
	case user.FieldCreated:
		m.ClearCreated()
		return nil
	case user.FieldModified:
		m.ClearModified()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldCountry:
		m.ResetCountry()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldRegister:
		m.ResetRegister()
		return nil
	case user.FieldCertClearPassword:
		m.ResetCertClearPassword()
		return nil
	case user.FieldExpiry:
		m.ResetExpiry()
		return nil
	case user.FieldCreated:
		m.ResetCreated()
		return nil
	case user.FieldModified:
		m.ResetModified()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
